{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Code/POS_Project/pos-frontend/node_modules/qz-tray/qz-tray.js"],"sourcesContent":["'use strict';\n\n/**\n * @version 2.2.5\n * @overview QZ Tray Connector\n * @license LGPL-2.1-only\n * <p/>\n * Connects a web client to the QZ Tray software.\n * Enables printing and device communication from javascript.\n */\nvar qz = (function() {\n\n///// POLYFILLS /////\n\n    if (!Array.isArray) {\n        Array.isArray = function(arg) {\n            return Object.prototype.toString.call(arg) === '[object Array]';\n        };\n    }\n\n    if (!Number.isInteger) {\n        Number.isInteger = function(value) {\n            return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;\n        };\n    }\n\n///// PRIVATE METHODS /////\n\n    var _qz = {\n        VERSION: \"2.2.5\",                              //must match @version above\n        DEBUG: false,\n\n        log: {\n            /** Debugging messages */\n            trace: function() { if (_qz.DEBUG) { console.log.apply(console, arguments); } },\n            /** General messages */\n            info: function() { console.info.apply(console, arguments); },\n            /** General warnings */\n            warn: function() { console.warn.apply(console, arguments); },\n            /** Debugging errors */\n            allay: function() { if (_qz.DEBUG) { console.warn.apply(console, arguments); } },\n            /** General errors */\n            error: function() { console.error.apply(console, arguments); }\n        },\n\n\n        //stream types\n        streams: {\n            serial: 'SERIAL', usb: 'USB', hid: 'HID', printer: 'PRINTER', file: 'FILE', socket: 'SOCKET'\n        },\n\n\n        websocket: {\n            /** The actual websocket object managing the connection. */\n            connection: null,\n            /** Track if a connection attempt is being cancelled. */\n            shutdown: false,\n\n            /** Default parameters used on new connections. Override values using options parameter on {@link qz.websocket.connect}. */\n            connectConfig: {\n                host: [\"localhost\", \"localhost.qz.io\"], //hosts QZ Tray can be running on\n                hostIndex: 0,                           //internal var - index on host array\n                usingSecure: true,                      //boolean use of secure protocol\n                protocol: {\n                    secure: \"wss://\",                   //secure websocket\n                    insecure: \"ws://\"                   //insecure websocket\n                },\n                port: {\n                    secure: [8181, 8282, 8383, 8484],   //list of secure ports QZ Tray could be listening on\n                    insecure: [8182, 8283, 8384, 8485], //list of insecure ports QZ Tray could be listening on\n                    portIndex: 0                        //internal var - index on active port array\n                },\n                keepAlive: 60,                          //time between pings to keep connection alive, in seconds\n                retries: 0,                             //number of times to reconnect before failing\n                delay: 0                                //seconds before firing a connection\n            },\n\n            setup: {\n                /** Loop through possible ports to open connection, sets web socket calls that will settle the promise. */\n                findConnection: function(config, resolve, reject) {\n                    if (_qz.websocket.shutdown) {\n                        reject(new Error(\"Connection attempt cancelled by user\"));\n                        return;\n                    }\n\n                    //force flag if missing ports\n                    if (!config.port.secure.length) {\n                        if (!config.port.insecure.length) {\n                            reject(new Error(\"No ports have been specified to connect over\"));\n                            return;\n                        } else if (config.usingSecure) {\n                            _qz.log.error(\"No secure ports specified - forcing insecure connection\");\n                            config.usingSecure = false;\n                        }\n                    } else if (!config.port.insecure.length && !config.usingSecure) {\n                        _qz.log.trace(\"No insecure ports specified - forcing secure connection\");\n                        config.usingSecure = true;\n                    }\n\n                    var deeper = function() {\n                        if (_qz.websocket.shutdown) {\n                            //connection attempt was cancelled, bail out\n                            reject(new Error(\"Connection attempt cancelled by user\"));\n                            return;\n                        }\n\n                        config.port.portIndex++;\n\n                        if ((config.usingSecure && config.port.portIndex >= config.port.secure.length)\n                            || (!config.usingSecure && config.port.portIndex >= config.port.insecure.length)) {\n                            if (config.hostIndex >= config.host.length - 1) {\n                                //give up, all hope is lost\n                                reject(new Error(\"Unable to establish connection with QZ\"));\n                                return;\n                            } else {\n                                config.hostIndex++;\n                                config.port.portIndex = 0;\n                            }\n                        }\n\n                        // recursive call until connection established or all ports are exhausted\n                        _qz.websocket.setup.findConnection(config, resolve, reject);\n                    };\n\n                    var address;\n                    if (config.usingSecure) {\n                        address = config.protocol.secure + config.host[config.hostIndex] + \":\" + config.port.secure[config.port.portIndex];\n                    } else {\n                        address = config.protocol.insecure + config.host[config.hostIndex] + \":\" + config.port.insecure[config.port.portIndex];\n                    }\n\n                    try {\n                        _qz.log.trace(\"Attempting connection\", address);\n                        _qz.websocket.connection = new _qz.tools.ws(address);\n                    }\n                    catch(err) {\n                        _qz.log.error(err);\n                        deeper();\n                        return;\n                    }\n\n                    if (_qz.websocket.connection != null) {\n                        _qz.websocket.connection.established = false;\n\n                        //called on successful connection to qz, begins setup of websocket calls and resolves connect promise after certificate is sent\n                        _qz.websocket.connection.onopen = function(evt) {\n                            if (!_qz.websocket.connection.established) {\n                                _qz.log.trace(evt);\n                                _qz.log.info(\"Established connection with QZ Tray on \" + address);\n\n                                _qz.websocket.setup.openConnection({ resolve: resolve, reject: reject });\n\n                                if (config.keepAlive > 0) {\n                                    var interval = setInterval(function() {\n                                        if (!_qz.tools.isActive() || _qz.websocket.connection.interval !== interval) {\n                                            clearInterval(interval);\n                                            return;\n                                        }\n\n                                        _qz.websocket.connection.send(\"ping\");\n                                    }, config.keepAlive * 1000);\n\n                                    _qz.websocket.connection.interval = interval;\n                                }\n                            }\n                        };\n\n                        //called during websocket close during setup\n                        _qz.websocket.connection.onclose = function() {\n                            // Safari compatibility fix to raise error event\n                            if (_qz.websocket.connection && typeof navigator !== 'undefined' && navigator.userAgent.indexOf('Safari') != -1 && navigator.userAgent.indexOf('Chrome') == -1) {\n                                _qz.websocket.connection.onerror();\n                            }\n                        };\n\n                        //called for errors during setup (such as invalid ports), reject connect promise only if all ports have been tried\n                        _qz.websocket.connection.onerror = function(evt) {\n                            _qz.log.trace(evt);\n\n                            _qz.websocket.connection = null;\n\n                            deeper();\n                        };\n                    } else {\n                        reject(new Error(\"Unable to create a websocket connection\"));\n                    }\n                },\n\n                /** Finish setting calls on successful connection, sets web socket calls that won't settle the promise. */\n                openConnection: function(openPromise) {\n                    _qz.websocket.connection.established = true;\n\n                    //called when an open connection is closed\n                    _qz.websocket.connection.onclose = function(evt) {\n                        _qz.log.trace(evt);\n\n                        _qz.websocket.connection = null;\n                        _qz.websocket.callClose(evt);\n                        _qz.log.info(\"Closed connection with QZ Tray\");\n\n                        for(var uid in _qz.websocket.pendingCalls) {\n                            if (_qz.websocket.pendingCalls.hasOwnProperty(uid)) {\n                                _qz.websocket.pendingCalls[uid].reject(new Error(\"Connection closed before response received\"));\n                            }\n                        }\n\n                        //if this is set, then an explicit close call was made\n                        if (this.promise != undefined) {\n                            this.promise.resolve();\n                        }\n                    };\n\n                    //called for any errors with an open connection\n                    _qz.websocket.connection.onerror = function(evt) {\n                        _qz.websocket.callError(evt);\n                    };\n\n                    //send JSON objects to qz\n                    _qz.websocket.connection.sendData = function(obj) {\n                        _qz.log.trace(\"Preparing object for websocket\", obj);\n\n                        if (obj.timestamp == undefined) {\n                            obj.timestamp = Date.now();\n                            if (typeof obj.timestamp !== 'number') {\n                                obj.timestamp = new Date().getTime();\n                            }\n                        }\n                        if (obj.promise != undefined) {\n                            obj.uid = _qz.websocket.setup.newUID();\n                            _qz.websocket.pendingCalls[obj.uid] = obj.promise;\n                        }\n\n                        // track requesting monitor\n                        obj.position = {\n                            x: typeof screen !== 'undefined' ? ((screen.availWidth || screen.width) / 2) + (screen.left || screen.availLeft || 0) : 0,\n                            y: typeof screen !== 'undefined' ? ((screen.availHeight || screen.height) / 2) + (screen.top || screen.availTop || 0) : 0\n                        };\n\n                        try {\n                            if (obj.call != undefined && obj.signature == undefined && _qz.security.needsSigned(obj.call)) {\n                                var signObj = {\n                                    call: obj.call,\n                                    params: obj.params,\n                                    timestamp: obj.timestamp\n                                };\n\n                                //make a hashing promise if not already one\n                                var hashing = _qz.tools.hash(_qz.tools.stringify(signObj));\n                                if (!hashing.then) {\n                                    hashing = _qz.tools.promise(function(resolve) {\n                                        resolve(hashing);\n                                    });\n                                }\n\n                                hashing.then(function(hashed) {\n                                    return _qz.security.callSign(hashed);\n                                }).then(function(signature) {\n                                    _qz.log.trace(\"Signature for call\", signature);\n                                    obj.signature = signature || \"\";\n                                    obj.signAlgorithm = _qz.security.signAlgorithm;\n\n                                    _qz.signContent = undefined;\n                                    _qz.websocket.connection.send(_qz.tools.stringify(obj));\n                                }).catch(function(err) {\n                                    _qz.log.error(\"Signing failed\", err);\n\n                                    if (obj.promise != undefined) {\n                                        obj.promise.reject(new Error(\"Failed to sign request\"));\n                                        delete _qz.websocket.pendingCalls[obj.uid];\n                                    }\n                                });\n                            } else {\n                                _qz.log.trace(\"Signature for call\", obj.signature);\n\n                                //called for pre-signed content and (unsigned) setup calls\n                                _qz.websocket.connection.send(_qz.tools.stringify(obj));\n                            }\n                        }\n                        catch(err) {\n                            _qz.log.error(err);\n\n                            if (obj.promise != undefined) {\n                                obj.promise.reject(err);\n                                delete _qz.websocket.pendingCalls[obj.uid];\n                            }\n                        }\n                    };\n\n                    //receive message from qz\n                    _qz.websocket.connection.onmessage = function(evt) {\n                        var returned = JSON.parse(evt.data);\n\n                        if (returned.uid == null) {\n                            if (returned.type == null) {\n                                //incorrect response format, likely connected to incompatible qz version\n                                _qz.websocket.connection.close(4003, \"Connected to incompatible QZ Tray version\");\n\n                            } else {\n                                //streams (callbacks only, no promises)\n                                switch(returned.type) {\n                                    case _qz.streams.serial:\n                                        if (!returned.event) {\n                                            returned.event = JSON.stringify({ portName: returned.key, output: returned.data });\n                                        }\n\n                                        _qz.serial.callSerial(JSON.parse(returned.event));\n                                        break;\n                                    case _qz.streams.socket:\n                                        _qz.socket.callSocket(JSON.parse(returned.event));\n                                        break;\n                                    case _qz.streams.usb:\n                                        if (!returned.event) {\n                                            returned.event = JSON.stringify({ vendorId: returned.key[0], productId: returned.key[1], output: returned.data });\n                                        }\n\n                                        _qz.usb.callUsb(JSON.parse(returned.event));\n                                        break;\n                                    case _qz.streams.hid:\n                                        _qz.hid.callHid(JSON.parse(returned.event));\n                                        break;\n                                    case _qz.streams.printer:\n                                        _qz.printers.callPrinter(JSON.parse(returned.event));\n                                        break;\n                                    case _qz.streams.file:\n                                        _qz.file.callFile(JSON.parse(returned.event));\n                                        break;\n                                    default:\n                                        _qz.log.allay(\"Cannot determine stream type for callback\", returned);\n                                        break;\n                                }\n                            }\n\n                            return;\n                        }\n\n                        _qz.log.trace(\"Received response from websocket\", returned);\n\n                        var promise = _qz.websocket.pendingCalls[returned.uid];\n                        if (promise == undefined) {\n                            _qz.log.allay('No promise found for returned response');\n                        } else {\n                            if (returned.error != undefined) {\n                                promise.reject(new Error(returned.error));\n                            } else {\n                                promise.resolve(returned.result);\n                            }\n                        }\n\n                        delete _qz.websocket.pendingCalls[returned.uid];\n                    };\n\n\n                    //send up the certificate before making any calls\n                    //also gives the user a chance to deny the connection\n                    function sendCert(cert) {\n                        if (cert === undefined) { cert = null; }\n\n                        //websocket setup, query what version is connected\n                        qz.api.getVersion().then(function(version) {\n                            _qz.websocket.connection.version = version;\n                            _qz.websocket.connection.semver = version.toLowerCase().replace(/-rc\\./g, \"-rc\").split(/[\\\\+\\\\.-]/g);\n                            for(var i = 0; i < _qz.websocket.connection.semver.length; i++) {\n                                try {\n                                    if (i == 3 && _qz.websocket.connection.semver[i].toLowerCase().indexOf(\"rc\") == 0) {\n                                        // Handle \"rc1\" pre-release by negating build info\n                                        _qz.websocket.connection.semver[i] = -(_qz.websocket.connection.semver[i].replace(/\\D/g, \"\"));\n                                        continue;\n                                    }\n                                    _qz.websocket.connection.semver[i] = parseInt(_qz.websocket.connection.semver[i]);\n                                }\n                                catch(ignore) {}\n\n                                if (_qz.websocket.connection.semver.length < 4) {\n                                    _qz.websocket.connection.semver[3] = 0;\n                                }\n                            }\n\n                            //algorithm can be declared before a connection, check for incompatibilities now that we have one\n                            _qz.compatible.algorithm(true);\n                        }).then(function() {\n                            _qz.websocket.connection.sendData({ certificate: cert, promise: openPromise });\n                        });\n                    }\n\n                    _qz.security.callCert().then(sendCert).catch(function(error) {\n                        _qz.log.warn(\"Failed to get certificate:\", error);\n\n                        if (_qz.security.rejectOnCertFailure) {\n                            openPromise.reject(error);\n                        } else {\n                            sendCert(null);\n                        }\n                    });\n                },\n\n                /** Generate unique ID used to map a response to a call. */\n                newUID: function() {\n                    var len = 6;\n                    return (new Array(len + 1).join(\"0\") + (Math.random() * Math.pow(36, len) << 0).toString(36)).slice(-len)\n                }\n            },\n\n            dataPromise: function(callName, params, signature, signingTimestamp) {\n                return _qz.tools.promise(function(resolve, reject) {\n                    var msg = {\n                        call: callName,\n                        promise: { resolve: resolve, reject: reject },\n                        params: params,\n                        signature: signature,\n                        timestamp: signingTimestamp\n                    };\n\n                    _qz.websocket.connection.sendData(msg);\n                });\n            },\n\n            /** Library of promises awaiting a response, uid -> promise */\n            pendingCalls: {},\n\n            /** List of functions to call on error from the websocket. */\n            errorCallbacks: [],\n            /** Calls all functions registered to listen for errors. */\n            callError: function(evt) {\n                if (Array.isArray(_qz.websocket.errorCallbacks)) {\n                    for(var i = 0; i < _qz.websocket.errorCallbacks.length; i++) {\n                        _qz.websocket.errorCallbacks[i](evt);\n                    }\n                } else {\n                    _qz.websocket.errorCallbacks(evt);\n                }\n            },\n\n            /** List of function to call on closing from the websocket. */\n            closedCallbacks: [],\n            /** Calls all functions registered to listen for closing. */\n            callClose: function(evt) {\n                if (Array.isArray(_qz.websocket.closedCallbacks)) {\n                    for(var i = 0; i < _qz.websocket.closedCallbacks.length; i++) {\n                        _qz.websocket.closedCallbacks[i](evt);\n                    }\n                } else {\n                    _qz.websocket.closedCallbacks(evt);\n                }\n            }\n        },\n\n\n        printing: {\n            /** Default options used for new printer configs. Can be overridden using {@link qz.configs.setDefaults}. */\n            defaultConfig: {\n                //value purposes are explained in the qz.configs.setDefaults docs\n\n                bounds: null,\n                colorType: 'color',\n                copies: 1,\n                density: 0,\n                duplex: false,\n                fallbackDensity: null,\n                interpolation: 'bicubic',\n                jobName: null,\n                legacy: false,\n                margins: 0,\n                orientation: null,\n                paperThickness: null,\n                printerTray: null,\n                rasterize: false,\n                rotation: 0,\n                scaleContent: true,\n                size: null,\n                units: 'in',\n\n                forceRaw: false,\n                encoding: null,\n                spool: null\n            }\n        },\n\n\n        serial: {\n            /** List of functions called when receiving data from serial connection. */\n            serialCallbacks: [],\n            /** Calls all functions registered to listen for serial events. */\n            callSerial: function(streamEvent) {\n                if (Array.isArray(_qz.serial.serialCallbacks)) {\n                    for(var i = 0; i < _qz.serial.serialCallbacks.length; i++) {\n                        _qz.serial.serialCallbacks[i](streamEvent);\n                    }\n                } else {\n                    _qz.serial.serialCallbacks(streamEvent);\n                }\n            }\n        },\n\n\n        socket: {\n            /** List of functions called when receiving data from network socket connection. */\n            socketCallbacks: [],\n            /** Calls all functions registered to listen for network socket events. */\n            callSocket: function(socketEvent) {\n                if (Array.isArray(_qz.socket.socketCallbacks)) {\n                    for(var i = 0; i < _qz.socket.socketCallbacks.length; i++) {\n                        _qz.socket.socketCallbacks[i](socketEvent);\n                    }\n                } else {\n                    _qz.socket.socketCallbacks(socketEvent);\n                }\n            }\n        },\n\n\n        usb: {\n            /** List of functions called when receiving data from usb connection. */\n            usbCallbacks: [],\n            /** Calls all functions registered to listen for usb events. */\n            callUsb: function(streamEvent) {\n                if (Array.isArray(_qz.usb.usbCallbacks)) {\n                    for(var i = 0; i < _qz.usb.usbCallbacks.length; i++) {\n                        _qz.usb.usbCallbacks[i](streamEvent);\n                    }\n                } else {\n                    _qz.usb.usbCallbacks(streamEvent);\n                }\n            }\n        },\n\n\n        hid: {\n            /** List of functions called when receiving data from hid connection. */\n            hidCallbacks: [],\n            /** Calls all functions registered to listen for hid events. */\n            callHid: function(streamEvent) {\n                if (Array.isArray(_qz.hid.hidCallbacks)) {\n                    for(var i = 0; i < _qz.hid.hidCallbacks.length; i++) {\n                        _qz.hid.hidCallbacks[i](streamEvent);\n                    }\n                } else {\n                    _qz.hid.hidCallbacks(streamEvent);\n                }\n            }\n        },\n\n\n        printers: {\n            /** List of functions called when receiving data from printer connection. */\n            printerCallbacks: [],\n            /** Calls all functions registered to listen for printer events. */\n            callPrinter: function(streamEvent) {\n                if (Array.isArray(_qz.printers.printerCallbacks)) {\n                    for(var i = 0; i < _qz.printers.printerCallbacks.length; i++) {\n                        _qz.printers.printerCallbacks[i](streamEvent);\n                    }\n                } else {\n                    _qz.printers.printerCallbacks(streamEvent);\n                }\n            }\n        },\n\n\n        file: {\n            /** List of functions called when receiving info regarding file changes. */\n            fileCallbacks: [],\n            /** Calls all functions registered to listen for file events. */\n            callFile: function(streamEvent) {\n                if (Array.isArray(_qz.file.fileCallbacks)) {\n                    for(var i = 0; i < _qz.file.fileCallbacks.length; i++) {\n                        _qz.file.fileCallbacks[i](streamEvent);\n                    }\n                } else {\n                    _qz.file.fileCallbacks(streamEvent);\n                }\n            }\n        },\n\n\n        security: {\n            /** Function used to resolve promise when acquiring site's public certificate. */\n            certHandler: function(resolve, reject) { reject(); },\n            /** Called to create new promise (using {@link _qz.security.certHandler}) for certificate retrieval. */\n            callCert: function() {\n                if (typeof _qz.security.certHandler.then === 'function') {\n                    //already a promise\n                    return _qz.security.certHandler;\n                } else if (_qz.security.certHandler.constructor.name === \"AsyncFunction\") {\n                    //already callable as a promise\n                    return _qz.security.certHandler();\n                } else {\n                    //turn into a promise\n                    return _qz.tools.promise(_qz.security.certHandler);\n                }\n            },\n\n            /** Function used to create promise resolver when requiring signed calls. */\n            signatureFactory: function() { return function(resolve) { resolve(); } },\n            /** Called to create new promise (using {@link _qz.security.signatureFactory}) for signed calls. */\n            callSign: function(toSign) {\n                if (_qz.security.signatureFactory.constructor.name === \"AsyncFunction\") {\n                    //use directly\n                    return _qz.security.signatureFactory(toSign);\n                } else {\n                    //use in a promise\n                    return _qz.tools.promise(_qz.security.signatureFactory(toSign));\n                }\n            },\n\n            /** Signing algorithm used on signatures */\n            signAlgorithm: \"SHA1\",\n\n            rejectOnCertFailure: false,\n\n            needsSigned: function(callName) {\n                const undialoged = [\n                    \"printers.getStatus\",\n                    \"printers.stopListening\",\n                    \"usb.isClaimed\",\n                    \"usb.closeStream\",\n                    \"usb.releaseDevice\",\n                    \"hid.stopListening\",\n                    \"hid.isClaimed\",\n                    \"hid.closeStream\",\n                    \"hid.releaseDevice\",\n                    \"file.stopListening\",\n                    \"getVersion\"\n                ];\n\n                return callName != null && undialoged.indexOf(callName) === -1;\n            }\n        },\n\n\n        tools: {\n            /** Create a new promise */\n            promise: function(resolver) {\n                //prefer global object for historical purposes\n                if (typeof RSVP !== 'undefined') {\n                    return new RSVP.Promise(resolver);\n                } else if (typeof Promise !== 'undefined') {\n                    return new Promise(resolver);\n                } else {\n                    _qz.log.error(\"Promise/A+ support is required.  See qz.api.setPromiseType(...)\");\n                }\n            },\n\n            /** Stub for rejecting with an Error from withing a Promise */\n            reject: function(error) {\n                return _qz.tools.promise(function(resolve, reject) {\n                    reject(error);\n                });\n            },\n\n            stringify: function(object) {\n                //old versions of prototype affect stringify\n                var pjson = Array.prototype.toJSON;\n                delete Array.prototype.toJSON;\n\n                function skipKeys(key, value) {\n                    if (key === \"promise\") {\n                        return undefined;\n                    }\n\n                    return value;\n                }\n\n                var result = JSON.stringify(object, skipKeys);\n\n                if (pjson) {\n                    Array.prototype.toJSON = pjson;\n                }\n\n                return result;\n            },\n\n            hash: function(data) {\n                //prefer global object for historical purposes\n                if (typeof Sha256 !== 'undefined') {\n                    return Sha256.hash(data);\n                } else {\n                    return _qz.SHA.hash(data);\n                }\n            },\n\n            ws: typeof WebSocket !== 'undefined' ? WebSocket : null,\n\n            absolute: function(loc) {\n                if (typeof window !== 'undefined' && typeof document.createElement === 'function') {\n                    var a = document.createElement(\"a\");\n                    a.href = loc;\n                    return a.href;\n                } else if (typeof exports === 'object') {\n                    //node.js\n                    require('path').resolve(loc);\n                }\n                return loc;\n            },\n\n            relative: function(data) {\n                for(var i = 0; i < data.length; i++) {\n                    if (data[i].constructor === Object) {\n                        var absolute = false;\n\n                        if (data[i].data && data[i].data.search && data[i].data.search(/data:image\\/\\w+;base64,/) === 0) {\n                            //upgrade from old base64 behavior\n                            data[i].flavor = \"base64\";\n                            data[i].data = data[i].data.replace(/^data:image\\/\\w+;base64,/, \"\");\n                        } else if (data[i].flavor) {\n                            //if flavor is known, we can directly check for absolute flavor types\n                            if ([\"FILE\", \"XML\"].indexOf(data[i].flavor.toUpperCase()) > -1) {\n                                absolute = true;\n                            }\n                        } else if (data[i].format && [\"HTML\", \"IMAGE\", \"PDF\", \"FILE\", \"XML\"].indexOf(data[i].format.toUpperCase()) > -1) {\n                            //if flavor is not known, all valid pixel formats default to file flavor\n                            //previous v2.0 data also used format as what is now flavor, so we check for those values here too\n                            absolute = true;\n                        } else if (data[i].type && (([\"PIXEL\", \"IMAGE\", \"PDF\"].indexOf(data[i].type.toUpperCase()) > -1 && !data[i].format)\n                            || ([\"HTML\", \"PDF\"].indexOf(data[i].type.toUpperCase()) > -1 && (!data[i].format || data[i].format.toUpperCase() === \"FILE\")))) {\n                            //if all we know is pixel type, then it is image's file flavor\n                            //previous v2.0 data also used type as what is now format, so we check for those value here too\n                            absolute = true;\n                        }\n\n                        if (absolute) {\n                            //change relative links to absolute\n                            data[i].data = _qz.tools.absolute(data[i].data);\n                        }\n                        if (data[i].options && typeof data[i].options.overlay === 'string') {\n                            data[i].options.overlay = _qz.tools.absolute(data[i].options.overlay);\n                        }\n                    }\n                }\n            },\n\n            /** Performs deep copy to target from remaining params */\n            extend: function(target) {\n                //special case when reassigning properties as objects in a deep copy\n                if (typeof target !== 'object') {\n                    target = {};\n                }\n\n                for(var i = 1; i < arguments.length; i++) {\n                    var source = arguments[i];\n                    if (!source) { continue; }\n\n                    for(var key in source) {\n                        if (source.hasOwnProperty(key)) {\n                            if (target === source[key]) { continue; }\n\n                            if (source[key] && source[key].constructor && source[key].constructor === Object) {\n                                var clone;\n                                if (Array.isArray(source[key])) {\n                                    clone = target[key] || [];\n                                } else {\n                                    clone = target[key] || {};\n                                }\n\n                                target[key] = _qz.tools.extend(clone, source[key]);\n                            } else if (source[key] !== undefined) {\n                                target[key] = source[key];\n                            }\n                        }\n                    }\n                }\n\n                return target;\n            },\n\n            versionCompare: function(major, minor, patch, build) {\n                if (_qz.tools.assertActive()) {\n                    var semver = _qz.websocket.connection.semver;\n                    if (semver[0] != major) {\n                        return semver[0] - major;\n                    }\n                    if (minor != undefined && semver[1] != minor) {\n                        return semver[1] - minor;\n                    }\n                    if (patch != undefined && semver[2] != patch) {\n                        return semver[2] - patch;\n                    }\n                    if (build != undefined && semver.length > 3 && semver[3] != build) {\n                        return Number.isInteger(semver[3]) && Number.isInteger(build) ? semver[3] - build : semver[3].toString().localeCompare(build.toString());\n                    }\n                    return 0;\n                }\n            },\n\n            isVersion: function(major, minor, patch, build) {\n                return _qz.tools.versionCompare(major, minor, patch, build) == 0;\n            },\n\n            isActive: function() {\n                return !_qz.websocket.shutdown && _qz.websocket.connection != null\n                    && (_qz.websocket.connection.readyState === _qz.tools.ws.OPEN\n                        || _qz.websocket.connection.readyState === _qz.tools.ws.CONNECTING);\n            },\n\n            assertActive: function() {\n                if (_qz.tools.isActive()) {\n                    return true;\n                }\n                // Promise won't reject on throw; yet better than 'undefined'\n                throw new Error(\"A connection to QZ has not been established yet\");\n            },\n\n            uint8ArrayToHex: function(uint8) {\n                return Array.from(uint8)\n                    .map(function(i) { return i.toString(16).padStart(2, '0'); })\n                    .join('');\n            },\n\n            uint8ArrayToBase64: function(uint8) {\n                /**\n                 * Adapted from Egor Nepomnyaschih's code under MIT Licence (C) 2020\n                 * see https://gist.github.com/enepomnyaschih/72c423f727d395eeaa09697058238727\n                 */\n                var map = [\n                    \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\",\n                    \"V\", \"W\", \"X\", \"Y\", \"Z\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\",\n                    \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"+\", \"/\"\n                ];\n\n                var result = '', i, l = uint8.length;\n                for (i = 2; i < l; i += 3) {\n                    result += map[uint8[i - 2] >> 2];\n                    result += map[((uint8[i - 2] & 0x03) << 4) | (uint8[i - 1] >> 4)];\n                    result += map[((uint8[i - 1] & 0x0F) << 2) | (uint8[i] >> 6)];\n                    result += map[uint8[i] & 0x3F];\n                }\n                if (i === l + 1) { // 1 octet yet to write\n                    result += map[uint8[i - 2] >> 2];\n                    result += map[(uint8[i - 2] & 0x03) << 4];\n                    result += \"==\";\n                }\n                if (i === l) { // 2 octets yet to write\n                    result += map[uint8[i - 2] >> 2];\n                    result += map[((uint8[i - 2] & 0x03) << 4) | (uint8[i - 1] >> 4)];\n                    result += map[(uint8[i - 1] & 0x0F) << 2];\n                    result += \"=\";\n                }\n                return result;\n            },\n        },\n\n        compatible: {\n            /** Converts message format to a previous version's */\n            data: function(printData) {\n                // special handling for Uint8Array\n                for(var i = 0; i < printData.length; i++) {\n                    if (printData[i].constructor === Object && printData[i].data instanceof Uint8Array) {\n                        if (printData[i].flavor) {\n                            var flavor = printData[i].flavor.toString().toUpperCase();\n                            switch(flavor) {\n                                case 'BASE64':\n                                    printData[i].data = _qz.tools.uint8ArrayToBase64(printData[i].data);\n                                    break;\n                                case 'HEX':\n                                    printData[i].data = _qz.tools.uint8ArrayToHex(printData[i].data);\n                                    break;\n                                default:\n                                    throw new Error(\"Uint8Array conversion to '\" + flavor + \"' is not supported.\");\n                            }\n                        }\n                    }\n                }\n\n                if(_qz.tools.versionCompare(2, 2, 4) < 0) {\n                    for(var i = 0; i < printData.length; i++) {\n                        if (printData[i].constructor === Object) {\n                            // dotDensity: \"double-legacy|single-legacy\" since 2.2.4.  Fallback to \"double|single\"\n                            if (printData[i].options && typeof printData[i].options.dotDensity === 'string') {\n                                printData[i].options.dotDensity = printData[i].options.dotDensity.toLowerCase().replace(\"-legacy\", \"\");\n                            }\n                        }\n                    }\n                }\n\n                if (_qz.tools.isVersion(2, 0)) {\n                    /*\n                    2.0.x conversion\n                    -----\n                    type=pixel -> use format as 2.0 type (unless 'command' format, which forces 2.0 'raw' type)\n                    type=raw -> 2.0 type has to be 'raw'\n                                if format is 'image' -> force 2.0 'image' format, ignore everything else (unsupported in 2.0)\n\n                     flavor translates straight to 2.0 format (unless forced to 'raw'/'image')\n                     */\n                    _qz.log.trace(\"Converting print data to v2.0 for \" + _qz.websocket.connection.version);\n                    for(var i = 0; i < printData.length; i++) {\n                        if (printData[i].constructor === Object) {\n                            if (printData[i].type && printData[i].type.toUpperCase() === \"RAW\" && printData[i].format && printData[i].format.toUpperCase() === \"IMAGE\") {\n                                if (printData[i].flavor && printData[i].flavor.toUpperCase() === \"BASE64\") {\n                                    //special case for raw base64 images\n                                    printData[i].data = \"data:image/compat;base64,\" + printData[i].data;\n                                }\n                                printData[i].flavor = \"IMAGE\"; //forces 'image' format when shifting for conversion\n                            }\n                            if ((printData[i].type && printData[i].type.toUpperCase() === \"RAW\") || (printData[i].format && printData[i].format.toUpperCase() === \"COMMAND\")) {\n                                printData[i].format = \"RAW\"; //forces 'raw' type when shifting for conversion\n                            }\n\n                            printData[i].type = printData[i].format;\n                            printData[i].format = printData[i].flavor;\n                            delete printData[i].flavor;\n                        }\n                    }\n                }\n            },\n\n            /* Converts config defaults to match previous version */\n            config: function(config, dirty) {\n                if (_qz.tools.isVersion(2, 0)) {\n                    if (!dirty.rasterize) {\n                        config.rasterize = true;\n                    }\n                }\n                if(_qz.tools.versionCompare(2, 2) < 0) {\n                    if(config.forceRaw !== 'undefined') {\n                        config.altPrinting = config.forceRaw;\n                        delete config.forceRaw;\n                    }\n                }\n                if(_qz.tools.versionCompare(2, 1, 2, 11) < 0) {\n                    if(config.spool) {\n                        if(config.spool.size) {\n                            config.perSpool = config.spool.size;\n                            delete config.spool.size;\n                        }\n                        if(config.spool.end) {\n                            config.endOfDoc = config.spool.end;\n                            delete config.spool.end;\n                        }\n                        delete config.spool;\n                    }\n                }\n                return config;\n            },\n\n            /** Compat wrapper with previous version **/\n            networking: function(hostname, port, signature, signingTimestamp, mappingCallback) {\n                // Use 2.0\n                if (_qz.tools.isVersion(2, 0)) {\n                    return _qz.tools.promise(function(resolve, reject) {\n                        _qz.websocket.dataPromise('websocket.getNetworkInfo', {\n                            hostname: hostname,\n                            port: port\n                        }, signature, signingTimestamp).then(function(data) {\n                            if (typeof mappingCallback !== 'undefined') {\n                                resolve(mappingCallback(data));\n                            } else {\n                                resolve(data);\n                            }\n                        }, reject);\n                    });\n                }\n                // Wrap 2.1\n                return _qz.tools.promise(function(resolve, reject) {\n                    _qz.websocket.dataPromise('networking.device', {\n                        hostname: hostname,\n                        port: port\n                    }, signature, signingTimestamp).then(function(data) {\n                        resolve({ ipAddress: data.ip, macAddress: data.mac });\n                    }, reject);\n                });\n            },\n\n            /** Check if QZ version supports chosen algorithm */\n            algorithm: function(quiet) {\n                //if not connected yet we will assume compatibility exists for the time being\n                //check semver to guard race condition for pending connections\n                if (_qz.tools.isActive() && _qz.websocket.connection.semver) {\n                    if (_qz.tools.isVersion(2, 0)) {\n                        if (!quiet) {\n                            _qz.log.warn(\"Connected to an older version of QZ, alternate signature algorithms are not supported\");\n                        }\n                        return false;\n                    }\n                }\n\n                return true;\n            }\n        },\n\n        /**\n         * Adapted from Chris Veness's code under MIT Licence (C) 2002\n         * see http://www.movable-type.co.uk/scripts/sha256.html\n         */\n        SHA: {\n            //@formatter:off - keep this block compact\n            hash: function(msg) {\n                // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n                msg = _qz.SHA._utf8Encode(msg) + String.fromCharCode(0x80);\n\n                // constants [§4.2.2]\n                var K = [\n                    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n                    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n                    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n                    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n                    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n                    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n                    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n                    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n                ];\n                // initial hash value [§5.3.1]\n                var H = [ 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19 ];\n\n                // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n                var l = msg.length / 4 + 2; // length (in 32-bit integers) of msg + ‘1’ + appended length\n                var N = Math.ceil(l / 16);  // number of 16-integer-blocks required to hold 'l' ints\n                var M = new Array(N);\n\n                for(var i = 0; i < N; i++) {\n                    M[i] = new Array(16);\n                    for(var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n                        M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                            (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n                    } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n                }\n                // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n                // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n                // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n                M[N-1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32);\n                M[N-1][14] = Math.floor(M[N-1][14]);\n                M[N-1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n                // HASH COMPUTATION [§6.1.2]\n                var W = new Array(64); var a, b, c, d, e, f, g, h;\n                for(var i = 0; i < N; i++) {\n                    // 1 - prepare message schedule 'W'\n                    for(var t = 0; t < 16; t++) { W[t] = M[i][t]; }\n                    for(var t = 16; t < 64; t++) { W[t] = (_qz.SHA._dev1(W[t-2]) + W[t-7] + _qz.SHA._dev0(W[t-15]) + W[t-16]) & 0xffffffff; }\n                    // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n                    a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n                    // 3 - main loop (note 'addition modulo 2^32')\n                    for(var t = 0; t < 64; t++) {\n                        var T1 = h + _qz.SHA._sig1(e) + _qz.SHA._ch(e, f, g) + K[t] + W[t];\n                        var T2 = _qz.SHA._sig0(a) + _qz.SHA._maj(a, b, c);\n                        h = g; g = f; f = e; e = (d + T1) & 0xffffffff;\n                        d = c; c = b; b = a; a = (T1 + T2) & 0xffffffff;\n                    }\n                    // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n                    H[0] = (H[0]+a) & 0xffffffff; H[1] = (H[1]+b) & 0xffffffff; H[2] = (H[2]+c) & 0xffffffff; H[3] = (H[3]+d) & 0xffffffff;\n                    H[4] = (H[4]+e) & 0xffffffff; H[5] = (H[5]+f) & 0xffffffff; H[6] = (H[6]+g) & 0xffffffff; H[7] = (H[7]+h) & 0xffffffff;\n                }\n\n                return _qz.SHA._hexStr(H[0]) + _qz.SHA._hexStr(H[1]) + _qz.SHA._hexStr(H[2]) + _qz.SHA._hexStr(H[3]) +\n                    _qz.SHA._hexStr(H[4]) + _qz.SHA._hexStr(H[5]) + _qz.SHA._hexStr(H[6]) + _qz.SHA._hexStr(H[7]);\n            },\n\n            // Rotates right (circular right shift) value x by n positions\n            _rotr: function(n, x) { return (x >>> n) | (x << (32 - n)); },\n            // logical functions\n            _sig0: function(x) { return _qz.SHA._rotr(2, x) ^ _qz.SHA._rotr(13, x) ^ _qz.SHA._rotr(22, x); },\n            _sig1: function(x) { return _qz.SHA._rotr(6, x) ^ _qz.SHA._rotr(11, x) ^ _qz.SHA._rotr(25, x); },\n            _dev0: function(x) { return _qz.SHA._rotr(7, x) ^ _qz.SHA._rotr(18, x) ^ (x >>> 3); },\n            _dev1: function(x) { return _qz.SHA._rotr(17, x) ^ _qz.SHA._rotr(19, x) ^ (x >>> 10); },\n            _ch: function(x, y, z) { return (x & y) ^ (~x & z); },\n            _maj: function(x, y, z) { return (x & y) ^ (x & z) ^ (y & z); },\n            // note can't use toString(16) as it is implementation-dependant, and in IE returns signed numbers when used on full words\n            _hexStr: function(n) { var s = \"\", v; for(var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); } return s; },\n            // implementation of deprecated unescape() based on https://cwestblog.com/2011/05/23/escape-unescape-deprecated/ (and comments)\n            _unescape: function(str) {\n                return str.replace(/%(u[\\da-f]{4}|[\\da-f]{2})/gi, function(seq) {\n                    if (seq.length - 1) {\n                        return String.fromCharCode(parseInt(seq.substring(seq.length - 3 ? 2 : 1), 16))\n                    } else {\n                        var code = seq.charCodeAt(0);\n                        return code < 256 ? \"%\" + (0 + code.toString(16)).slice(-2).toUpperCase() : \"%u\" + (\"000\" + code.toString(16)).slice(-4).toUpperCase()\n                    }\n                });\n            },\n            _utf8Encode: function(str) {\n                return _qz.SHA._unescape(encodeURIComponent(str));\n            }\n            //@formatter:on\n        },\n    };\n\n\n///// CONFIG CLASS ////\n\n    /** Object to handle configured printer options. */\n    function Config(printer, opts) {\n\n        this.config = _qz.tools.extend({}, _qz.printing.defaultConfig); //create a copy of the default options\n        this._dirtyOpts = {}; //track which config options have changed from the defaults\n\n        /**\n         * Set the printer assigned to this config.\n         * @param {string|Object} newPrinter Name of printer. Use object type to specify printing to file or host.\n         *  @param {string} [newPrinter.name] Name of printer to send printing.\n         *  @param {string} [newPrinter.file] DEPRECATED: Name of file to send printing.\n         *  @param {string} [newPrinter.host] IP address or host name to send printing.\n         *  @param {string} [newPrinter.port] Port used by &lt;printer.host>.\n         */\n        this.setPrinter = function(newPrinter) {\n            if (typeof newPrinter === 'string') {\n                newPrinter = { name: newPrinter };\n            }\n            this.printer = newPrinter;\n        };\n\n        /**\n         *  @returns {Object} The printer currently assigned to this config.\n         */\n        this.getPrinter = function() {\n            return this.printer;\n        };\n\n        /**\n         * Alter any of the printer options currently applied to this config.\n         * @param newOpts {Object} The options to change. See <code>qz.configs.setDefaults</code> docs for available values.\n         *\n         * @see qz.configs.setDefaults\n         */\n        this.reconfigure = function(newOpts) {\n            for(var key in newOpts) {\n                if (newOpts[key] !== undefined) {\n                    this._dirtyOpts[key] = true;\n                }\n            }\n\n            _qz.tools.extend(this.config, newOpts);\n        };\n\n        /**\n         * @returns {Object} The currently applied options on this config.\n         */\n        this.getOptions = function() {\n            return _qz.compatible.config(this.config, this._dirtyOpts);\n        };\n\n        // init calls for new config object\n        this.setPrinter(printer);\n        this.reconfigure(opts);\n    }\n\n    /**\n     * Shortcut method for calling <code>qz.print</code> with a particular config.\n     * @param {Array<Object|string>} data Array of data being sent to the printer. See <code>qz.print</code> docs for available values.\n     * @param {boolean} [signature] Pre-signed signature of JSON string containing <code>call</code>, <code>params</code>, and <code>timestamp</code>.\n     * @param {number} [signingTimestamp] Required with <code>signature</code>. Timestamp used with pre-signed content.\n     *\n     * @example\n     * qz.print(myConfig, ...); // OR\n     * myConfig.print(...);\n     *\n     * @see qz.print\n     */\n    Config.prototype.print = function(data, signature, signingTimestamp) {\n        qz.print(this, data, signature, signingTimestamp);\n    };\n\n\n///// PUBLIC METHODS /////\n\n    /** @namespace qz */\n    var qz = {\n\n        /**\n         * Calls related specifically to the web socket connection.\n         * @namespace qz.websocket\n         */\n        websocket: {\n            /**\n             * Check connection status. Active connection is necessary for other calls to run.\n             *\n             * @returns {boolean} If there is an active connection with QZ Tray.\n             *\n             * @see connect\n             *\n             * @memberof  qz.websocket\n             */\n            isActive: function() {\n                return _qz.tools.isActive();\n            },\n\n            /**\n             * Call to setup connection with QZ Tray on user's system.\n             *\n             * @param {Object} [options] Configuration options for the web socket connection.\n             *  @param {string|Array<string>} [options.host=['localhost', 'localhost.qz.io']] Host running the QZ Tray software.\n             *  @param {Object} [options.port] Config options for ports to cycle.\n             *   @param {Array<number>} [options.port.secure=[8181, 8282, 8383, 8484]] Array of secure (WSS) ports to try\n             *   @param {Array<number>} [options.port.insecure=[8182, 8283, 8384, 8485]] Array of insecure (WS) ports to try\n             *  @param {boolean} [options.usingSecure=true] If the web socket should try to use secure ports for connecting.\n             *  @param {number} [options.keepAlive=60] Seconds between keep-alive pings to keep connection open. Set to 0 to disable.\n             *  @param {number} [options.retries=0] Number of times to reconnect before failing.\n             *  @param {number} [options.delay=0] Seconds before firing a connection.  Ignored if <code>options.retries</code> is 0.\n             *\n             * @returns {Promise<null|Error>}\n             *\n             * @memberof qz.websocket\n             */\n            connect: function(options) {\n                return _qz.tools.promise(function(resolve, reject) {\n                    if (_qz.websocket.connection) {\n                        const state = _qz.websocket.connection.readyState;\n\n                        if (state === _qz.tools.ws.OPEN) {\n                            reject(new Error(\"An open connection with QZ Tray already exists\"));\n                            return;\n                        } else if (state === _qz.tools.ws.CONNECTING) {\n                            reject(new Error(\"The current connection attempt has not returned yet\"));\n                            return;\n                        } else if (state === _qz.tools.ws.CLOSING) {\n                            reject(new Error(\"Waiting for previous disconnect request to complete\"));\n                            return;\n                        }\n                    }\n\n                    if (!_qz.tools.ws) {\n                        reject(new Error(\"WebSocket not supported by this browser\"));\n                        return;\n                    } else if (!_qz.tools.ws.CLOSED || _qz.tools.ws.CLOSED == 2) {\n                        reject(new Error(\"Unsupported WebSocket version detected: HyBi-00/Hixie-76\"));\n                        return;\n                    }\n\n                    //ensure some form of options exists for value checks\n                    if (options == undefined) { options = {}; }\n\n                    //disable secure ports if page is not secure\n                    if (typeof location === 'undefined' || location.protocol !== 'https:') {\n                        //respect forcing secure ports if it is defined, otherwise disable\n                        if (typeof options.usingSecure === 'undefined') {\n                            _qz.log.trace(\"Disabling secure ports due to insecure page\");\n                            options.usingSecure = false;\n                        }\n                    }\n\n                    //ensure any hosts are passed to internals as an array\n                    if (typeof options.host !== 'undefined' && !Array.isArray(options.host)) {\n                        options.host = [options.host];\n                    }\n\n                    _qz.websocket.shutdown = false; //reset state for new connection attempt\n                    var attempt = function(count) {\n                        var tried = false;\n                        var nextAttempt = function() {\n                            if (!tried) {\n                                tried = true;\n\n                                if (options && count < options.retries) {\n                                    attempt(count + 1);\n                                } else {\n                                    _qz.websocket.connection = null;\n                                    reject.apply(null, arguments);\n                                }\n                            }\n                        };\n\n                        var delayed = function() {\n                            var config = _qz.tools.extend({}, _qz.websocket.connectConfig, options);\n                            _qz.websocket.setup.findConnection(config, resolve, nextAttempt)\n                        };\n                        if (count == 0) {\n                            delayed(); // only retries will be called with a delay\n                        } else {\n                            setTimeout(delayed, options.delay * 1000);\n                        }\n                    };\n\n                    attempt(0);\n                });\n            },\n\n            /**\n             * Stop any active connection with QZ Tray.\n             *\n             * @returns {Promise<null|Error>}\n             *\n             * @memberof qz.websocket\n             */\n            disconnect: function() {\n                return _qz.tools.promise(function(resolve, reject) {\n                    if (_qz.websocket.connection != null) {\n                        if (_qz.tools.isActive()) {\n                            // handles closing both 'connecting' and 'connected' states\n                            _qz.websocket.shutdown = true;\n                            _qz.websocket.connection.promise = { resolve: resolve, reject: reject };\n                            _qz.websocket.connection.close();\n                        } else {\n                            reject(new Error(\"Current connection is still closing\"));\n                        }\n                    } else {\n                        reject(new Error(\"No open connection with QZ Tray\"));\n                    }\n                });\n            },\n\n            /**\n             * List of functions called for any connections errors outside of an API call.<p/>\n             * Also called if {@link websocket#connect} fails to connect.\n             *\n             * @param {Function|Array<Function>} calls Single or array of <code>Function({Event} event)</code> calls.\n             *\n             * @memberof qz.websocket\n             */\n            setErrorCallbacks: function(calls) {\n                _qz.websocket.errorCallbacks = calls;\n            },\n\n            /**\n             * List of functions called for any connection closing event outside of an API call.<p/>\n             * Also called when {@link websocket#disconnect} is called.\n             *\n             * @param {Function|Array<Function>} calls Single or array of <code>Function({Event} event)</code> calls.\n             *\n             * @memberof qz.websocket\n             */\n            setClosedCallbacks: function(calls) {\n                _qz.websocket.closedCallbacks = calls;\n            },\n\n            /**\n             * @deprecated Since 2.1.0.  Please use qz.networking.device() instead\n             *\n             * @param {string} [hostname] Hostname to try to connect to when determining network interfaces, defaults to \"google.com\"\n             * @param {number} [port] Port to use with custom hostname, defaults to 443\n             * @param {string} [signature] Pre-signed signature of hashed JSON string containing <code>call='websocket.getNetworkInfo'</code>, <code>params</code> object, and <code>timestamp</code>.\n             * @param {number} [signingTimestamp] Required with <code>signature</code>. Timestamp used with pre-signed content.\n             *\n             * @returns {Promise<Object<{ipAddress: string, macAddress: string}>|Error>} Connected system's network information.\n             *\n             * @memberof qz.websocket\n             */\n            getNetworkInfo: _qz.compatible.networking,\n\n            /**\n             * @returns {Object<{socket: String, host: String, port: Number}>} Details of active websocket connection\n             *\n             * @memberof qz.websocket\n             */\n            getConnectionInfo: function() {\n                if (_qz.tools.assertActive()) {\n                    var url = _qz.websocket.connection.url.split(/[:\\/]+/g);\n                    return { socket: url[0], host: url[1], port: +url[2] };\n                }\n            }\n        },\n\n\n        /**\n         * Calls related to getting printer information from the connection.\n         * @namespace qz.printers\n         */\n        printers: {\n            /**\n             * @param {string} [signature] Pre-signed signature of hashed JSON string containing <code>call='printers.getDefault</code>, <code>params</code>, and <code>timestamp</code>.\n             * @param {number} [signingTimestamp] Required with <code>signature</code>. Timestamp used with pre-signed content.\n             *\n             * @returns {Promise<string|Error>} Name of the connected system's default printer.\n             *\n             * @memberof qz.printers\n             */\n            getDefault: function(signature, signingTimestamp) {\n                return _qz.websocket.dataPromise('printers.getDefault', null, signature, signingTimestamp);\n            },\n\n            /**\n             * @param {string} [query] Search for a specific printer. All printers are returned if not provided.\n             * @param {string} [signature] Pre-signed signature of hashed JSON string containing <code>call='printers.find'</code>, <code>params</code>, and <code>timestamp</code>.\n             * @param {number} [signingTimestamp] Required with <code>signature</code>. Timestamp used with pre-signed content.\n             *\n             * @returns {Promise<Array<string>|string|Error>} The matched printer name if <code>query</code> is provided.\n             *                                                Otherwise an array of printer names found on the connected system.\n             *\n             * @memberof qz.printers\n             */\n            find: function(query, signature, signingTimestamp) {\n                return _qz.websocket.dataPromise('printers.find', { query: query }, signature, signingTimestamp);\n            },\n\n            /**\n             * Provides a list, with additional information, for each printer available to QZ.\n             *\n             * @returns {Promise<Array<Object>|Object|Error>}\n             *\n             * @memberof qz.printers\n             */\n            details: function() {\n                return _qz.websocket.dataPromise('printers.detail');\n            },\n\n            /**\n             * Start listening for printer status events, such as paper_jam events.\n             * Reported under the ACTION type in the streamEvent on callbacks.\n             *\n             * @returns {Promise<null|Error>}\n             * @since 2.1.0\n             *\n             * @see qz.printers.setPrinterCallbacks\n             *\n             * @param {null|string|Array<string>} printers Printer or list of printers to listen to, null listens to all.\n             * @param {Object|null} [options] Printer listener options\n             *  @param {null|boolean} [options.jobData=false] Flag indicating if raw spool file content should be return as well as status information (Windows only)\n             *  @param {null|number} [options.maxJobData=-1] Maximum number of bytes to returns for raw spooled file content (Windows only)\n             *  @param {null|string} [options.flavor=\"plain\"] Flavor of data format returned. Valid flavors are <code>[base64 | hex | plain*]</code> (Windows only)\n             *\n             * @memberof qz.printers\n             */\n            startListening: function(printers, options) {\n                if (!Array.isArray(printers)) {\n                    printers = [printers];\n                }\n                var params = {\n                    printerNames: printers\n                };\n                if (options && options.jobData == true) params.jobData = true;\n                if (options && options.maxJobData) params.maxJobData = options.maxJobData;\n                if (options && options.flavor) params.flavor = options.flavor;\n                return _qz.websocket.dataPromise('printers.startListening', params);\n            },\n\n            /**\n             * Clear the queue of a specified printer or printers. Does not delete retained jobs.\n             *\n             * @param {string|Object} [options] Name of printer to clear\n             *  @param {string} [options.printerName] Name of printer to clear\n             *  @param {number} [options.jobId] Cancel a job of a specific JobId instead of canceling all. Must include a printerName.\n             *\n             * @returns {Promise<null|Error>}\n             * @since 2.2.4\n             *\n             * @memberof qz.printers\n             */\n            clearQueue: function(options) {\n                if (typeof options !== 'object') {\n                    options = {\n                        printerName: options\n                    };\n                }\n                return _qz.websocket.dataPromise('printers.clearQueue', options);\n            },\n\n            /**\n             * Stop listening for printer status actions.\n             *\n             * @returns {Promise<null|Error>}\n             * @since 2.1.0\n             *\n             * @see qz.printers.setPrinterCallbacks\n             *\n             * @memberof qz.printers\n             */\n            stopListening: function() {\n                return _qz.websocket.dataPromise('printers.stopListening');\n            },\n\n            /**\n             * Retrieve current printer status from any active listeners.\n             *\n             * @returns {Promise<null|Error>}\n             * @since 2.1.0\n             *\n             * @see qz.printers.startListening\n             *\n             * @memberof qz.printers\n             */\n            getStatus: function() {\n                return _qz.websocket.dataPromise('printers.getStatus');\n            },\n\n            /**\n             * List of functions called for any printer status change.\n             * Event data will contain <code>{string} printerName</code> and <code>{string} status</code> for all types.\n             *  For RECEIVE types, <code>{Array} output</code> (in hexadecimal format).\n             *  For ERROR types, <code>{string} exception</code>.\n             *  For ACTION types, <code>{string} actionType</code>.\n             *\n             * @param {Function|Array<Function>} calls Single or array of <code>Function({Object} eventData)</code> calls.\n             * @since 2.1.0\n             *\n             * @memberof qz.printers\n             */\n            setPrinterCallbacks: function(calls) {\n                _qz.printers.printerCallbacks = calls;\n            }\n        },\n\n        /**\n         * Calls related to setting up new printer configurations.\n         * @namespace qz.configs\n         */\n        configs: {\n            /**\n             * Default options used by new configs if not overridden.\n             * Setting a value to NULL will use the printer's default options.\n             * Updating these will not update the options on any created config.\n             *\n             * @param {Object} options Default options used by printer configs if not overridden.\n             *\n             *  @param {Object} [options.bounds=null] Bounding box rectangle.\n             *   @param {number} [options.bounds.x=0] Distance from left for bounding box starting corner\n             *   @param {number} [options.bounds.y=0] Distance from top for bounding box starting corner\n             *   @param {number} [options.bounds.width=0] Width of bounding box\n             *   @param {number} [options.bounds.height=0] Height of bounding box\n             *  @param {string} [options.colorType='color'] Valid values <code>[color | grayscale | blackwhite | default]</code>\n             *  @param {number} [options.copies=1] Number of copies to be printed.\n             *  @param {number|Array<number>|Object|Array<Object>|string} [options.density=0] Pixel density (DPI, DPMM, or DPCM depending on <code>[options.units]</code>).\n             *      If provided as an array, uses the first supported density found (or the first entry if none found).\n             *      If provided as a string, valid values are <code>[best | draft]</code>, corresponding to highest or lowest reported density respectively.\n             *  @param {number} [options.density.cross=0] Asymmetric pixel density for the cross feed direction.\n             *  @param {number} [options.density.feed=0] Asymmetric pixel density for the feed direction.\n             *  @param {boolean|string} [options.duplex=false] Double sided printing, Can specify duplex style by passing a string value: <code>[one-sided | duplex | long-edge | tumble | short-edge]</code>\n             *  @param {number} [options.fallbackDensity=null] Value used when default density value cannot be read, or in cases where reported as \"Normal\" by the driver, (in DPI, DPMM, or DPCM depending on <code>[options.units]</code>).\n             *  @param {string} [options.interpolation='bicubic'] Valid values <code>[bicubic | bilinear | nearest-neighbor]</code>. Controls how images are handled when resized.\n             *  @param {string} [options.jobName=null] Name to display in print queue.\n             *  @param {boolean} [options.legacy=false] If legacy style printing should be used.\n             *  @param {Object|number} [options.margins=0] If just a number is provided, it is used as the margin for all sides.\n             *   @param {number} [options.margins.top=0]\n             *   @param {number} [options.margins.right=0]\n             *   @param {number} [options.margins.bottom=0]\n             *   @param {number} [options.margins.left=0]\n             *  @param {string} [options.orientation=null] Valid values <code>[portrait | landscape | reverse-landscape | null]</code>.\n             *                                             If set to <code>null</code>, orientation will be determined automatically.\n             *  @param {number} [options.paperThickness=null]\n             *  @param {string|number} [options.printerTray=null] Printer tray to pull from. The number N assumes string equivalent of 'Tray N'. Uses printer default if NULL.\n             *  @param {boolean} [options.rasterize=false] Whether documents should be rasterized before printing.\n             *                                             Specifying <code>[options.density]</code> for PDF print formats will set this to <code>true</code>.\n             *  @param {number} [options.rotation=0] Image rotation in degrees.\n             *  @param {boolean} [options.scaleContent=true] Scales print content to page size, keeping ratio.\n             *  @param {Object} [options.size=null] Paper size.\n             *   @param {number} [options.size.width=null] Page width.\n             *   @param {number} [options.size.height=null] Page height.\n             *  @param {string} [options.units='in'] Page units, applies to paper size, margins, and density. Valid value <code>[in | cm | mm]</code>\n             *\n             *  @param {boolean} [options.forceRaw=false] Print the specified raw data using direct method, skipping the driver.  Not yet supported on Windows.\n             *  @param {string|Object} [options.encoding=null] Character set for commands. Can be provided as an object for converting encoding types for RAW types.\n             *   @param {string} [options.encoding.from] If this encoding type is provided, RAW type commands will be parsed from this for the purpose of being converted to the <code>encoding.to</code> value.\n             *   @param {string} [options.encoding.to] Encoding RAW type commands will be converted into. If <Code>encoding.from</code> is not provided, this will be treated as if a string was passed for encoding.\n             *  @param {string} [options.endOfDoc=null] DEPRECATED Raw only: Character(s) denoting end of a page to control spooling.\n             *  @param {number} [options.perSpool=1] DEPRECATED: Raw only: Number of pages per spool.\n             *  @param {boolean} [options.retainTemp=false] Retain any temporary files used.  Ignored unless <code>forceRaw</code> <code>true</code>.\n             *  @param {Object} [options.spool=null] Advanced spooling options.\n             *   @param {number} [options.spool.size=null] Number of pages per spool.  Default is no limit.  If <code>spool.end</code> is provided, defaults to <code>1</code>\n             *   @param {string} [options.spool.end=null] Raw only: Character(s) denoting end of a page to control spooling.\n             *\n             * @memberof qz.configs\n             */\n            setDefaults: function(options) {\n                _qz.tools.extend(_qz.printing.defaultConfig, options);\n            },\n\n            /**\n             * Creates new printer config to be used in printing.\n             *\n             * @param {string|object} printer Name of printer. Use object type to specify printing to file or host.\n             *  @param {string} [printer.name] Name of printer to send printing.\n             *  @param {string} [printer.file] Name of file to send printing.\n             *  @param {string} [printer.host] IP address or host name to send printing.\n             *  @param {string} [printer.port] Port used by &lt;printer.host>.\n             * @param {Object} [options] Override any of the default options for this config only.\n             *\n             * @returns {Config} The new config.\n             *\n             * @see configs.setDefaults\n             *\n             * @memberof qz.configs\n             */\n            create: function(printer, options) {\n                return new Config(printer, options);\n            }\n        },\n\n\n        /**\n         * Send data to selected config for printing.\n         * The promise for this method will resolve when the document has been sent to the printer. Actual printing may not be complete.\n         * <p/>\n         * Optionally, print requests can be pre-signed:\n         * Signed content consists of a JSON object string containing no spacing,\n         * following the format of the \"call\" and \"params\" keys in the API call, with the addition of a \"timestamp\" key in milliseconds\n         * ex. <code>'{\"call\":\"<callName>\",\"params\":{...},\"timestamp\":1450000000}'</code>\n         *\n         * @param {Object<Config>|Array<Object<Config>>} configs Previously created config object or objects.\n         * @param {Array<Object|string>|Array<Array<Object|string>>} data Array of data being sent to the printer.<br/>\n         *      String values are interpreted as <code>{type: 'raw', format: 'command', flavor: 'plain', data: &lt;string>}</code>.\n         *  @param {string} data.data\n         *  @param {string} data.type Printing type. Valid types are <code>[pixel | raw*]</code>. *Default\n         *  @param {string} data.format Format of data type used. *Default per type<p/>\n         *      For <code>[pixel]</code> types, valid formats are <code>[html | image* | pdf]</code>.<p/>\n         *      For <code>[raw]</code> types, valid formats are <code>[command* | html | image | pdf]</code>.\n         *  @param {string} data.flavor Flavor of data format used. *Default per format<p/>\n         *      For <code>[command]</code> formats, valid flavors are <code>[base64 | file | hex | plain* | xml]</code>.<p/>\n         *      For <code>[html]</code> formats, valid flavors are <code>[file* | plain]</code>.<p/>\n         *      For <code>[image]</code> formats, valid flavors are <code>[base64 | file*]</code>.<p/>\n         *      For <code>[pdf]</code> formats, valid flavors are <code>[base64 | file*]</code>.\n         *  @param {Object} [data.options]\n         *   @param {string} [data.options.language] Required with <code>[raw]</code> type + <code>[image]</code> format. Printer language.\n         *   @param {number} [data.options.x] Optional with <code>[raw]</code> type + <code>[image]</code> format. The X position of the image.\n         *   @param {number} [data.options.y] Optional with <code>[raw]</code> type + <code>[image]</code> format. The Y position of the image.\n         *   @param {string|number} [data.options.dotDensity] Optional with <code>[raw]</code> type + <code>[image]</code> format.\n         *   @param {number} [data.precision=128] Optional with <code>[raw]</code> type <code>[image]</code> format. Bit precision of the ribbons.\n         *   @param {boolean|string|Array<Array<number>>} [data.options.overlay=false] Optional with <code>[raw]</code> type <code>[image]</code> format.\n         *       Boolean sets entire layer, string sets mask image, Array sets array of rectangles in format <code>[x1,y1,x2,y2]</code>.\n         *   @param {string} [data.options.xmlTag] Required with <code>[xml]</code> flavor. Tag name containing base64 formatted data.\n         *   @param {number} [data.options.pageWidth] Optional with <code>[html | pdf]</code> formats. Width of the rendering.\n         *       Defaults to paper width.\n         *   @param {number} [data.options.pageHeight] Optional with <code>[html | pdf]</code> formats. Height of the rendering.\n         *       Defaults to paper height for <code>[pdf]</code>, or auto sized for <code>[html]</code>.\n         *   @param {string} [data.options.pageRanges] Optional with <code>[pdf]</code> formats. Comma-separated list of page ranges to include.\n         *   @param {boolean} [data.options.ignoreTransparency=false] Optional with <code>[pdf]</code> formats. Instructs transparent PDF elements to be ignored.\n         *       Transparent PDF elements are known to degrade performance and quality when printing.\n         *   @param {boolean} [data.options.altFontRendering=false] Optional with <code>[pdf]</code> formats. Instructs PDF to be rendered using PDFBOX 1.8 techniques.\n         *       Drastically improves low-DPI PDF print quality on Windows.\n         * @param {...*} [arguments] Additionally three more parameters can be specified:<p/>\n         *     <code>{boolean} [resumeOnError=false]</code> Whether the chain should continue printing if it hits an error on one the the prints.<p/>\n         *     <code>{string|Array<string>} [signature]</code> Pre-signed signature(s) of the JSON string for containing <code>call</code>, <code>params</code>, and <code>timestamp</code>.<p/>\n         *     <code>{number|Array<number>} [signingTimestamps]</code> Required to match with <code>signature</code>. Timestamps for each of the passed pre-signed content.\n         *\n         * @returns {Promise<null|Error>}\n         *\n         * @see qz.configs.create\n         *\n         * @memberof qz\n         */\n        print: function(configs, data) {\n            var resumeOnError = false,\n                signatures = [],\n                signaturesTimestamps = [];\n\n            //find optional parameters\n            if (arguments.length >= 3) {\n                if (typeof arguments[2] === 'boolean') {\n                    resumeOnError = arguments[2];\n\n                    if (arguments.length >= 5) {\n                        signatures = arguments[3];\n                        signaturesTimestamps = arguments[4];\n                    }\n                } else if (arguments.length >= 4) {\n                    signatures = arguments[2];\n                    signaturesTimestamps = arguments[3];\n                }\n\n                //ensure values are arrays for consistency\n                if (signatures && !Array.isArray(signatures)) { signatures = [signatures]; }\n                if (signaturesTimestamps && !Array.isArray(signaturesTimestamps)) { signaturesTimestamps = [signaturesTimestamps]; }\n            }\n\n            if (!Array.isArray(configs)) { configs = [configs]; } //single config -> array of configs\n            if (!Array.isArray(data[0])) { data = [data]; } //single data array -> array of data arrays\n\n            //clean up data formatting\n            for(var d = 0; d < data.length; d++) {\n                _qz.tools.relative(data[d]);\n                _qz.compatible.data(data[d]);\n            }\n\n            var sendToPrint = function(mapping) {\n                var params = {\n                    printer: mapping.config.getPrinter(),\n                    options: mapping.config.getOptions(),\n                    data: mapping.data\n                };\n\n                return _qz.websocket.dataPromise('print', params, mapping.signature, mapping.timestamp);\n            };\n\n            //chain instead of Promise.all, so resumeOnError can collect each error\n            var chain = [];\n            for(var i = 0; i < configs.length || i < data.length; i++) {\n                (function(i_) {\n                    var map = {\n                        config: configs[Math.min(i_, configs.length - 1)],\n                        data: data[Math.min(i_, data.length - 1)],\n                        signature: signatures[i_],\n                        timestamp: signaturesTimestamps[i_]\n                    };\n\n                    chain.push(function() { return sendToPrint(map) });\n                })(i);\n            }\n\n            //setup to catch errors if needed\n            var fallThrough = null;\n            if (resumeOnError) {\n                var fallen = [];\n                fallThrough = function(err) { fallen.push(err); };\n\n                //final promise to reject any errors as a group\n                chain.push(function() {\n                    return _qz.tools.promise(function(resolve, reject) {\n                        fallen.length ? reject(fallen) : resolve();\n                    });\n                });\n            }\n\n            var last = null;\n            chain.reduce(function(sequence, link) {\n                last = sequence.catch(fallThrough).then(link); //catch is ignored if fallThrough is null\n                return last;\n            }, _qz.tools.promise(function(r) { r(); })); //an immediately resolved promise to start off the chain\n\n            //return last promise so users can chain off final action or catch when stopping on error\n            return last;\n        },\n\n\n        /**\n         * Calls related to interaction with serial ports.\n         * @namespace qz.serial\n         */\n        serial: {\n            /**\n             * @returns {Promise<Array<string>|Error>} Communication (RS232, COM, TTY) ports available on connected system.\n             *\n             * @memberof qz.serial\n             */\n            findPorts: function() {\n                return _qz.websocket.dataPromise('serial.findPorts');\n            },\n\n            /**\n             * List of functions called for any response from open serial ports.\n             * Event data will contain <code>{string} portName</code> for all types.\n             *  For RECEIVE types, <code>{string} output</code>.\n             *  For ERROR types, <code>{string} exception</code>.\n             *\n             * @param {Function|Array<Function>} calls Single or array of <code>Function({object} streamEvent)</code> calls.\n             *\n             * @memberof qz.serial\n             */\n            setSerialCallbacks: function(calls) {\n                _qz.serial.serialCallbacks = calls;\n            },\n\n            /**\n             * Opens a serial port for sending and receiving data\n             *\n             * @param {string} port Name of serial port to open.\n             * @param {Object} [options] Serial port configurations.\n             *  @param {number} [options.baudRate=9600] Serial port speed. Set to 0 for auto negotiation.\n             *  @param {number} [options.dataBits=8] Serial port data bits. Set to 0 for auto negotiation.\n             *  @param {number} [options.stopBits=1] Serial port stop bits. Set to 0 for auto negotiation.\n             *  @param {string} [options.parity='NONE'] Serial port parity. Set to AUTO for auto negotiation. Valid values <code>[NONE | EVEN | ODD | MARK | SPACE | AUTO]</code>\n             *  @param {string} [options.flowControl='NONE'] Serial port flow control. Set to AUTO for auto negotiation. Valid values <code>[NONE | XONXOFF | XONXOFF_OUT | XONXOFF_IN | RTSCTS | RTSCTS_OUT | RTSCTS_IN | AUTO]</code>\n             *  @param {string} [options.encoding='UTF-8'] Character set for communications.\n             *  @param {string} [options.start=0x0002] DEPRECATED: Legacy character denoting start of serial response. Use <code>options.rx.start</code> instead.\n             *  @param {string} [options.end=0x000D] DEPRECATED: Legacy character denoting end of serial response. Use <code>options.rx.end</code> instead.\n             *  @param {number} [options.width] DEPRECATED: Legacy use for fixed-width response serial communication. Use <code>options.rx.width</code> instead.\n             *  @param {Object} [options.rx] Serial communications response definitions. If an object is passed but no options are defined, all response data will be sent back as it is received unprocessed.\n             *   @param {string|Array<string>} [options.rx.start] Character(s) denoting start of response bytes. Used in conjunction with `end`, `width`, or `lengthbit` property.\n             *   @param {string} [options.rx.end] Character denoting end of response bytes. Used in conjunction with `start` property.\n             *   @param {number} [options.rx.width] Fixed width size of response bytes (not including header if `start` is set). Used alone or in conjunction with `start` property.\n             *   @param {boolean} [options.rx.untilNewline] Returns data between newline characters (`\\n` or `\\r`) Truncates empty responses.  Overrides `start`, `end`, `width`.\n             *   @param {number|Object} [options.rx.lengthBytes] If a number is passed it is treated as the length index. Other values are left as their defaults.\n             *    @param {number} [options.rx.lengthBytes.index=0] Position of the response byte (not including response `start` bytes) used to denote the length of the remaining response data.\n             *    @param {number} [options.rx.lengthBytes.length=1] Length of response length bytes after response header.\n             *    @param {string} [options.rx.lengthBytes.endian='BIG'] Byte endian for multi-byte length values. Valid values <code>[BIG | LITTLE]</code>\n             *   @param {number|Object} [options.rx.crcBytes] If a number is passed it is treated as the crc length. Other values are left as their defaults.\n             *    @param {number} [options.rx.crcBytes.index=0] Position after the response data (not including length or data bytes) used to denote the crc.\n             *    @param {number} [options.rx.crcBytes.length=1] Length of response crc bytes after the response data length.\n             *   @param {boolean} [options.rx.includeHeader=false] Whether any of the header bytes (`start` bytes and any length bytes) should be included in the processed response.\n             *   @param {string} [options.rx.encoding] Override the encoding used for response data. Uses the same value as <code>options.encoding</code> otherwise.\n             *\n             * @returns {Promise<null|Error>}\n             *\n             * @memberof qz.serial\n             */\n            openPort: function(port, options) {\n                var params = {\n                    port: port,\n                    options: options\n                };\n                return _qz.websocket.dataPromise('serial.openPort', params);\n            },\n\n            /**\n             * Send commands over a serial port.\n             * Any responses from the device will be sent to serial callback functions.\n             *\n             * @param {string} port An open serial port to send data.\n             * @param {string|Array<string>|Object} data Data to be sent to the serial device.\n             *  @param {string} [data.type='PLAIN'] Valid values <code>[FILE | PLAIN | HEX | BASE64]</code>\n             *  @param {string|Array<string>} data.data Data to be sent to the serial device.\n             * @param {Object} options Serial port configuration updates. See <code>qz.serial.openPort</code> `options` docs for available values.\n             *     For best performance, it is recommended to only set these values on the port open call.\n             *\n             * @returns {Promise<null|Error>}\n             *\n             * @see qz.serial.setSerialCallbacks\n             *\n             * @memberof qz.serial\n             */\n            sendData: function(port, data, options) {\n                if (_qz.tools.versionCompare(2, 1, 0, 12) >= 0) {\n                    if (typeof data !== 'object') {\n                        data = {\n                            data: data,\n                            type: \"PLAIN\"\n                        }\n                    }\n\n                    if (data.type && data.type.toUpperCase() == \"FILE\") {\n                        data.data = _qz.tools.absolute(data.data);\n                    }\n                }\n\n                var params = {\n                    port: port,\n                    data: data,\n                    options: options\n                };\n                return _qz.websocket.dataPromise('serial.sendData', params);\n            },\n\n            /**\n             * @param {string} port Name of port to close.\n             *\n             * @returns {Promise<null|Error>}\n             *\n             * @memberof qz.serial\n             */\n            closePort: function(port) {\n                return _qz.websocket.dataPromise('serial.closePort', { port: port });\n            }\n        },\n\n        /**\n         * Calls related to interaction with communication sockets.\n         * @namespace qz.socket\n         */\n        socket: {\n            /**\n             * Opens a network port for sending and receiving data.\n             *\n             * @param {string} host The connection hostname.\n             * @param {number} port The connection port number.\n             * @param {Object} [options] Network socket configuration.\n             *  @param {string} [options.encoding='UTF-8'] Character set for communications.\n             *\n             * @memberof qz.socket\n             */\n            open: function(host, port, options) {\n                var params = {\n                    host: host,\n                    port: port,\n                    options: options\n                };\n                return _qz.websocket.dataPromise(\"socket.open\", params);\n            },\n\n            /**\n             * @param {string} host The connection hostname.\n             * @param {number} port The connection port number.\n             *\n             * @memberof qz.socket\n             */\n            close: function(host, port) {\n                var params = {\n                    host: host,\n                    port: port\n                };\n                return _qz.websocket.dataPromise(\"socket.close\", params);\n            },\n\n            /**\n             * Send data over an open socket.\n             *\n             * @param {string} host The connection hostname.\n             * @param {number} port The connection port number.\n             * @param {string|Object} data Data to be sent over the port.\n             *  @param {string} [data.type='PLAIN'] Valid values <code>[PLAIN]</code>\n             *  @param {string} data.data Data to be sent over the port.\n             *\n             * @memberof qz.socket\n             */\n            sendData: function(host, port, data) {\n                if (typeof data !== 'object') {\n                    data = {\n                        data: data,\n                        type: \"PLAIN\"\n                    };\n                }\n\n                var params = {\n                    host: host,\n                    port: port,\n                    data: data\n                };\n                return _qz.websocket.dataPromise(\"socket.sendData\", params);\n            },\n\n            /**\n             * List of functions called for any response from open network sockets.\n             * Event data will contain <code>{string} host</code> and <code>{number} port</code> for all types.\n             *  For RECEIVE types, <code>{string} response</code>.\n             *  For ERROR types, <code>{string} exception</code>.\n             *\n             * @param {Function|Array<Function>} calls Single or array of <code>Function({Object} eventData)</code> calls.\n             *\n             * @memberof qz.socket\n             */\n            setSocketCallbacks: function(calls) {\n                _qz.socket.socketCallbacks = calls;\n            }\n        },\n\n        /**\n         * Calls related to interaction with USB devices.\n         * @namespace qz.usb\n         */\n        usb: {\n            /**\n             * List of available USB devices. Includes (hexadecimal) vendor ID, (hexadecimal) product ID, and hub status.\n             * If supported, also returns manufacturer and product descriptions.\n             *\n             * @param includeHubs Whether to include USB hubs.\n             * @returns {Promise<Array<Object>|Error>} Array of JSON objects containing information on connected USB devices.\n             *\n             * @memberof qz.usb\n             */\n            listDevices: function(includeHubs) {\n                return _qz.websocket.dataPromise('usb.listDevices', { includeHubs: includeHubs });\n            },\n\n            /**\n             * @param {object} deviceInfo Config details of the HID device.\n             *  @param deviceInfo.vendorId Hex string of USB device's vendor ID.\n             *  @param deviceInfo.productId Hex string of USB device's product ID.\n             * @returns {Promise<Array<string>|Error>} List of available (hexadecimal) interfaces on a USB device.\n             *\n             * @memberof qz.usb\n             */\n            listInterfaces: function(deviceInfo) {\n                if (typeof deviceInfo !== 'object') { deviceInfo = { vendorId: arguments[0], productId: arguments[1] }; } //backwards compatibility\n\n                return _qz.websocket.dataPromise('usb.listInterfaces', deviceInfo);\n            },\n\n            /**\n             * @param {object} deviceInfo Config details of the HID device.\n             *  @param deviceInfo.vendorId Hex string of USB device's vendor ID.\n             *  @param deviceInfo.productId Hex string of USB device's product ID.\n             *  @param deviceInfo.iface Hex string of interface on the USB device to search.\n             * @returns {Promise<Array<string>|Error>} List of available (hexadecimal) endpoints on a USB device's interface.\n             *\n             * @memberof qz.usb\n             */\n            listEndpoints: function(deviceInfo) {\n                //backwards compatibility\n                if (typeof deviceInfo !== 'object') {\n                    deviceInfo = {\n                        vendorId: arguments[0],\n                        productId: arguments[1],\n                        interface: arguments[2]\n                    };\n                }\n\n                return _qz.websocket.dataPromise('usb.listEndpoints', deviceInfo);\n            },\n\n            /**\n             * List of functions called for any response from open usb devices.\n             * Event data will contain <code>{string} vendorId</code> and <code>{string} productId</code> for all types.\n             *  For RECEIVE types, <code>{Array} output</code> (in hexadecimal format).\n             *  For ERROR types, <code>{string} exception</code>.\n             *\n             * @param {Function|Array<Function>} calls Single or array of <code>Function({Object} eventData)</code> calls.\n             *\n             * @memberof qz.usb\n             */\n            setUsbCallbacks: function(calls) {\n                _qz.usb.usbCallbacks = calls;\n            },\n\n            /**\n             * Claim a USB device's interface to enable sending/reading data across an endpoint.\n             *\n             * @param {object} deviceInfo Config details of the HID device.\n             *  @param deviceInfo.vendorId Hex string of USB device's vendor ID.\n             *  @param deviceInfo.productId Hex string of USB device's product ID.\n             *  @param deviceInfo.interface Hex string of interface on the USB device to claim.\n             * @returns {Promise<null|Error>}\n             *\n             * @memberof qz.usb\n             */\n            claimDevice: function(deviceInfo) {\n                //backwards compatibility\n                if (typeof deviceInfo !== 'object') {\n                    deviceInfo = {\n                        vendorId: arguments[0],\n                        productId: arguments[1],\n                        interface: arguments[2]\n                    };\n                }\n\n                return _qz.websocket.dataPromise('usb.claimDevice', deviceInfo);\n            },\n\n            /**\n             * Check the current claim state of a USB device.\n             *\n             * @param {object} deviceInfo Config details of the HID device.\n             *  @param deviceInfo.vendorId Hex string of USB device's vendor ID.\n             *  @param deviceInfo.productId Hex string of USB device's product ID.\n             * @returns {Promise<boolean|Error>}\n             *\n             * @since 2.0.2\n             * @memberOf qz.usb\n             */\n            isClaimed: function(deviceInfo) {\n                if (typeof deviceInfo !== 'object') { deviceInfo = { vendorId: arguments[0], productId: arguments[1] }; } //backwards compatibility\n\n                return _qz.websocket.dataPromise('usb.isClaimed', deviceInfo);\n            },\n\n            /**\n             * Send data to a claimed USB device.\n             *\n             * @param {object} deviceInfo Config details of the HID device.\n             *  @param deviceInfo.vendorId Hex string of USB device's vendor ID.\n             *  @param deviceInfo.productId Hex string of USB device's product ID.\n             *  @param deviceInfo.endpoint Hex string of endpoint on the claimed interface for the USB device.\n             *  @param deviceInfo.data Bytes to send over specified endpoint.\n             *  @param {string} [deviceInfo.type='PLAIN'] Valid values <code>[FILE | PLAIN | HEX | BASE64]</code>\n             * @returns {Promise<null|Error>}\n             *\n             * @memberof qz.usb\n             */\n            sendData: function(deviceInfo) {\n                //backwards compatibility\n                if (typeof deviceInfo !== 'object') {\n                    deviceInfo = {\n                        vendorId: arguments[0],\n                        productId: arguments[1],\n                        endpoint: arguments[2],\n                        data: arguments[3]\n                    };\n                }\n\n                if (_qz.tools.versionCompare(2, 1, 0, 12) >= 0) {\n                    if (typeof deviceInfo.data !== 'object') {\n                        deviceInfo.data = {\n                            data: deviceInfo.data,\n                            type: \"PLAIN\"\n                        }\n                    }\n\n                    if (deviceInfo.data.type && deviceInfo.data.type.toUpperCase() == \"FILE\") {\n                        deviceInfo.data.data = _qz.tools.absolute(deviceInfo.data.data);\n                    }\n                }\n\n                return _qz.websocket.dataPromise('usb.sendData', deviceInfo);\n            },\n\n            /**\n             * Read data from a claimed USB device.\n             *\n             * @param {object} deviceInfo Config details of the HID device.\n             *  @param deviceInfo.vendorId Hex string of USB device's vendor ID.\n             *  @param deviceInfo.productId Hex string of USB device's product ID.\n             *  @param deviceInfo.endpoint Hex string of endpoint on the claimed interface for the USB device.\n             *  @param deviceInfo.responseSize Size of the byte array to receive a response in.\n             * @returns {Promise<Array<string>|Error>} List of (hexadecimal) bytes received from the USB device.\n             *\n             * @memberof qz.usb\n             */\n            readData: function(deviceInfo) {\n                //backwards compatibility\n                if (typeof deviceInfo !== 'object') {\n                    deviceInfo = {\n                        vendorId: arguments[0],\n                        productId: arguments[1],\n                        endpoint: arguments[2],\n                        responseSize: arguments[3]\n                    };\n                }\n\n                return _qz.websocket.dataPromise('usb.readData', deviceInfo);\n            },\n\n            /**\n             * Provides a continuous stream of read data from a claimed USB device.\n             *\n             * @param {object} deviceInfo Config details of the HID device.\n             *  @param deviceInfo.vendorId Hex string of USB device's vendor ID.\n             *  @param deviceInfo.productId Hex string of USB device's product ID.\n             *  @param deviceInfo.endpoint Hex string of endpoint on the claimed interface for the USB device.\n             *  @param deviceInfo.responseSize Size of the byte array to receive a response in.\n             *  @param deviceInfo.interval=100 Frequency to send read data back, in milliseconds.\n             * @returns {Promise<null|Error>}\n             *\n             * @see qz.usb.setUsbCallbacks\n             *\n             * @memberof qz.usb\n             */\n            openStream: function(deviceInfo) {\n                //backwards compatibility\n                if (typeof deviceInfo !== 'object') {\n                    deviceInfo = {\n                        vendorId: arguments[0],\n                        productId: arguments[1],\n                        endpoint: arguments[2],\n                        responseSize: arguments[3],\n                        interval: arguments[4]\n                    };\n                }\n\n                return _qz.websocket.dataPromise('usb.openStream', deviceInfo);\n            },\n\n            /**\n             * Stops the stream of read data from a claimed USB device.\n             *\n             * @param {object} deviceInfo Config details of the HID device.\n             *  @param deviceInfo.vendorId Hex string of USB device's vendor ID.\n             *  @param deviceInfo.productId Hex string of USB device's product ID.\n             *  @param deviceInfo.endpoint Hex string of endpoint on the claimed interface for the USB device.\n             * @returns {Promise<null|Error>}\n             *\n             * @memberof qz.usb\n             */\n            closeStream: function(deviceInfo) {\n                //backwards compatibility\n                if (typeof deviceInfo !== 'object') {\n                    deviceInfo = {\n                        vendorId: arguments[0],\n                        productId: arguments[1],\n                        endpoint: arguments[2]\n                    };\n                }\n\n                return _qz.websocket.dataPromise('usb.closeStream', deviceInfo);\n            },\n\n            /**\n             * Release a claimed USB device to free resources after sending/reading data.\n             *\n             * @param {object} deviceInfo Config details of the HID device.\n             *  @param deviceInfo.vendorId Hex string of USB device's vendor ID.\n             *  @param deviceInfo.productId Hex string of USB device's product ID.\n             * @returns {Promise<null|Error>}\n             *\n             * @memberof qz.usb\n             */\n            releaseDevice: function(deviceInfo) {\n                if (typeof deviceInfo !== 'object') { deviceInfo = { vendorId: arguments[0], productId: arguments[1] }; } //backwards compatibility\n\n                return _qz.websocket.dataPromise('usb.releaseDevice', deviceInfo);\n            }\n        },\n\n\n        /**\n         * Calls related to interaction with HID USB devices<br/>\n         * Many of these calls can be accomplished from the <code>qz.usb</code> namespace,\n         * but HID allows for simpler interaction\n         * @namespace qz.hid\n         * @since 2.0.1\n         */\n        hid: {\n            /**\n             * List of available HID devices. Includes (hexadecimal) vendor ID and (hexadecimal) product ID.\n             * If available, also returns manufacturer and product descriptions.\n             *\n             * @returns {Promise<Array<Object>|Error>} Array of JSON objects containing information on connected HID devices.\n             * @since 2.0.1\n             *\n             * @memberof qz.hid\n             */\n            listDevices: function() {\n                return _qz.websocket.dataPromise('hid.listDevices');\n            },\n\n            /**\n             * Start listening for HID device actions, such as attach / detach events.\n             * Reported under the ACTION type in the streamEvent on callbacks.\n             *\n             * @returns {Promise<null|Error>}\n             * @since 2.0.1\n             *\n             * @see qz.hid.setHidCallbacks\n             *\n             * @memberof qz.hid\n             */\n            startListening: function() {\n                return _qz.websocket.dataPromise('hid.startListening');\n            },\n\n            /**\n             * Stop listening for HID device actions.\n             *\n             * @returns {Promise<null|Error>}\n             * @since 2.0.1\n             *\n             * @see qz.hid.setHidCallbacks\n             *\n             * @memberof qz.hid\n             */\n            stopListening: function() {\n                return _qz.websocket.dataPromise('hid.stopListening');\n            },\n\n            /**\n             * List of functions called for any response from open usb devices.\n             * Event data will contain <code>{string} vendorId</code> and <code>{string} productId</code> for all types.\n             *  For RECEIVE types, <code>{Array} output</code> (in hexadecimal format).\n             *  For ERROR types, <code>{string} exception</code>.\n             *  For ACTION types, <code>{string} actionType</code>.\n             *\n             * @param {Function|Array<Function>} calls Single or array of <code>Function({Object} eventData)</code> calls.\n             * @since 2.0.1\n             *\n             * @memberof qz.hid\n             */\n            setHidCallbacks: function(calls) {\n                _qz.hid.hidCallbacks = calls;\n            },\n\n            /**\n             * Claim a HID device to enable sending/reading data across.\n             *\n             * @param {object} deviceInfo Config details of the HID device.\n             *  @param deviceInfo.vendorId Hex string of HID device's vendor ID.\n             *  @param deviceInfo.productId Hex string of HID device's product ID.\n             *  @param deviceInfo.usagePage Hex string of HID device's usage page when multiple are present.\n             *  @param deviceInfo.serial Serial ID of HID device.\n             * @returns {Promise<null|Error>}\n             * @since 2.0.1\n             *\n             * @memberof qz.hid\n             */\n            claimDevice: function(deviceInfo) {\n                if (typeof deviceInfo !== 'object') { deviceInfo = { vendorId: arguments[0], productId: arguments[1] }; } //backwards compatibility\n\n                return _qz.websocket.dataPromise('hid.claimDevice', deviceInfo);\n            },\n\n            /**\n             * Check the current claim state of a HID device.\n             *\n             * @param {object} deviceInfo Config details of the HID device.\n             *  @param deviceInfo.vendorId Hex string of HID device's vendor ID.\n             *  @param deviceInfo.productId Hex string of HID device's product ID.\n             *  @param deviceInfo.usagePage Hex string of HID device's usage page when multiple are present.\n             *  @param deviceInfo.serial Serial ID of HID device.\n             * @returns {Promise<boolean|Error>}\n             *\n             * @since 2.0.2\n             * @memberOf qz.hid\n             */\n            isClaimed: function(deviceInfo) {\n                if (typeof deviceInfo !== 'object') { deviceInfo = { vendorId: arguments[0], productId: arguments[1] }; } //backwards compatibility\n\n                return _qz.websocket.dataPromise('hid.isClaimed', deviceInfo);\n            },\n\n            /**\n             * Send data to a claimed HID device.\n             *\n             * @param {object} deviceInfo Config details of the HID device.\n             *  @param deviceInfo.vendorId Hex string of HID device's vendor ID.\n             *  @param deviceInfo.productId Hex string of HID device's product ID.\n             *  @param deviceInfo.usagePage Hex string of HID device's usage page when multiple are present.\n             *  @param deviceInfo.serial Serial ID of HID device.\n             *  @param deviceInfo.data Bytes to send over specified endpoint.\n             *  @param deviceInfo.endpoint=0x00 First byte of the data packet signifying the HID report ID.\n             *                             Must be 0x00 for devices only supporting a single report.\n             *  @param deviceInfo.reportId=0x00 Alias for <code>deviceInfo.endpoint</code>. Not used if endpoint is provided.\n             *  @param {string} [deviceInfo.type='PLAIN'] Valid values <code>[FILE | PLAIN | HEX | BASE64]</code>\n             * @returns {Promise<null|Error>}\n             * @since 2.0.1\n             *\n             * @memberof qz.hid\n             */\n            sendData: function(deviceInfo) {\n                //backwards compatibility\n                if (typeof deviceInfo !== 'object') {\n                    deviceInfo = {\n                        vendorId: arguments[0],\n                        productId: arguments[1],\n                        data: arguments[2],\n                        endpoint: arguments[3]\n                    };\n                }\n\n                if (_qz.tools.versionCompare(2, 1, 0, 12) >= 0) {\n                    if (typeof deviceInfo.data !== 'object') {\n                        deviceInfo.data = {\n                            data: deviceInfo.data,\n                            type: \"PLAIN\"\n                        }\n                    }\n\n                    if (deviceInfo.data.type && deviceInfo.data.type.toUpperCase() == \"FILE\") {\n                        deviceInfo.data.data = _qz.tools.absolute(deviceInfo.data.data);\n                    }\n                } else {\n                    if (typeof deviceInfo.data === 'object') {\n                        if (deviceInfo.data.type.toUpperCase() !== \"PLAIN\"\n                            || typeof deviceInfo.data.data !== \"string\") {\n                            return _qz.tools.reject(new Error(\"Data format is not supported with connected QZ Tray version \" + _qz.websocket.connection.version));\n                        }\n\n                        deviceInfo.data = deviceInfo.data.data;\n                    }\n                }\n\n                return _qz.websocket.dataPromise('hid.sendData', deviceInfo);\n            },\n\n            /**\n             * Read data from a claimed HID device.\n             *\n             * @param {object} deviceInfo Config details of the HID device.\n             *  @param deviceInfo.vendorId Hex string of HID device's vendor ID.\n             *  @param deviceInfo.productId Hex string of HID device's product ID.\n             *  @param deviceInfo.usagePage Hex string of HID device's usage page when multiple are present.\n             *  @param deviceInfo.serial Serial ID of HID device.\n             *  @param deviceInfo.responseSize Size of the byte array to receive a response in.\n             * @returns {Promise<Array<string>|Error>} List of (hexadecimal) bytes received from the HID device.\n             * @since 2.0.1\n             *\n             * @memberof qz.hid\n             */\n            readData: function(deviceInfo) {\n                //backwards compatibility\n                if (typeof deviceInfo !== 'object') {\n                    deviceInfo = {\n                        vendorId: arguments[0],\n                        productId: arguments[1],\n                        responseSize: arguments[2]\n                    };\n                }\n\n                return _qz.websocket.dataPromise('hid.readData', deviceInfo);\n            },\n\n            /**\n             * Send a feature report to a claimed HID device.\n             *\n             * @param {object} deviceInfo Config details of the HID device.\n             *  @param deviceInfo.vendorId Hex string of HID device's vendor ID.\n             *  @param deviceInfo.productId Hex string of HID device's product ID.\n             *  @param deviceInfo.usagePage Hex string of HID device's usage page when multiple are present.\n             *  @param deviceInfo.serial Serial ID of HID device.\n             *  @param deviceInfo.data Bytes to send over specified endpoint.\n             *  @param deviceInfo.endpoint=0x00 First byte of the data packet signifying the HID report ID.\n             *                             Must be 0x00 for devices only supporting a single report.\n             *  @param deviceInfo.reportId=0x00 Alias for <code>deviceInfo.endpoint</code>. Not used if endpoint is provided.\n             *  @param {string} [deviceInfo.type='PLAIN'] Valid values <code>[FILE | PLAIN | HEX | BASE64]</code>\n             * @returns {Promise<null|Error>}\n             *\n             * @memberof qz.hid\n             */\n            sendFeatureReport: function(deviceInfo) {\n                return _qz.websocket.dataPromise('hid.sendFeatureReport', deviceInfo);\n            },\n\n            /**\n             * Get a feature report from a claimed HID device.\n             *\n             * @param {object} deviceInfo Config details of the HID device.\n             *  @param deviceInfo.vendorId Hex string of HID device's vendor ID.\n             *  @param deviceInfo.productId Hex string of HID device's product ID.\n             *  @param deviceInfo.usagePage Hex string of HID device's usage page when multiple are present.\n             *  @param deviceInfo.serial Serial ID of HID device.\n             *  @param deviceInfo.responseSize Size of the byte array to receive a response in.\n             * @returns {Promise<Array<string>|Error>} List of (hexadecimal) bytes received from the HID device.\n             *\n             * @memberof qz.hid\n             */\n            getFeatureReport: function(deviceInfo) {\n                return _qz.websocket.dataPromise('hid.getFeatureReport', deviceInfo);\n            },\n\n            /**\n             * Provides a continuous stream of read data from a claimed HID device.\n             *\n             * @param {object} deviceInfo Config details of the HID device.\n             *  @param deviceInfo.vendorId Hex string of HID device's vendor ID.\n             *  @param deviceInfo.productId Hex string of HID device's product ID.\n             *  @param deviceInfo.usagePage Hex string of HID device's usage page when multiple are present.\n             *  @param deviceInfo.serial Serial ID of HID device.\n             *  @param deviceInfo.responseSize Size of the byte array to receive a response in.\n             *  @param deviceInfo.interval=100 Frequency to send read data back, in milliseconds.\n             * @returns {Promise<null|Error>}\n             * @since 2.0.1\n             *\n             * @see qz.hid.setHidCallbacks\n             *\n             * @memberof qz.hid\n             */\n            openStream: function(deviceInfo) {\n                //backwards compatibility\n                if (typeof deviceInfo !== 'object') {\n                    deviceInfo = {\n                        vendorId: arguments[0],\n                        productId: arguments[1],\n                        responseSize: arguments[2],\n                        interval: arguments[3]\n                    };\n                }\n\n                return _qz.websocket.dataPromise('hid.openStream', deviceInfo);\n            },\n\n            /**\n             * Stops the stream of read data from a claimed HID device.\n             *\n             * @param {object} deviceInfo Config details of the HID device.\n             *  @param deviceInfo.vendorId Hex string of HID device's vendor ID.\n             *  @param deviceInfo.productId Hex string of HID device's product ID.\n             *  @param deviceInfo.usagePage Hex string of HID device's usage page when multiple are present.\n             *  @param deviceInfo.serial Serial ID of HID device.\n             * @returns {Promise<null|Error>}\n             * @since 2.0.1\n             *\n             * @memberof qz.hid\n             */\n            closeStream: function(deviceInfo) {\n                if (typeof deviceInfo !== 'object') { deviceInfo = { vendorId: arguments[0], productId: arguments[1] }; } //backwards compatibility\n\n                return _qz.websocket.dataPromise('hid.closeStream', deviceInfo);\n            },\n\n            /**\n             * Release a claimed HID device to free resources after sending/reading data.\n             *\n             * @param {object} deviceInfo Config details of the HID device.\n             *  @param deviceInfo.vendorId Hex string of HID device's vendor ID.\n             *  @param deviceInfo.productId Hex string of HID device's product ID.\n             *  @param deviceInfo.usagePage Hex string of HID device's usage page when multiple are present.\n             *  @param deviceInfo.serial Serial ID of HID device.\n             * @returns {Promise<null|Error>}\n             * @since 2.0.1\n             *\n             * @memberof qz.hid\n             */\n            releaseDevice: function(deviceInfo) {\n                if (typeof deviceInfo !== 'object') { deviceInfo = { vendorId: arguments[0], productId: arguments[1] }; } //backwards compatibility\n\n                return _qz.websocket.dataPromise('hid.releaseDevice', deviceInfo);\n            }\n        },\n\n\n        /**\n         * Calls related to interactions with the filesystem\n         * @namespace qz.file\n         * @since 2.1\n         */\n        file: {\n            /**\n             * List of files available at the given directory.<br/>\n             * Due to security reasons, paths are limited to the qz data directory unless overridden via properties file.\n             *\n             * @param {string} path Relative or absolute directory path. Must reside in qz data directory or a white-listed location.\n             * @param {Object} [params] Object containing file access parameters\n             *  @param {boolean} [params.sandbox=true] If relative location from root is only available to the certificate's connection, otherwise all connections\n             *  @param {boolean} [params.shared=true] If relative location from root is accessible to all users on the system, otherwise just the current user\n             * @returns {Promise<Array<String>|Error>} Array of files at the given path\n             *\n             * @memberof qz.file\n             */\n            list: function(path, params) {\n                var param = _qz.tools.extend({ path: path }, params);\n                return _qz.websocket.dataPromise('file.list', param);\n            },\n\n            /**\n             * Reads contents of file at the given path.<br/>\n             * Due to security reasons, paths are limited to the qz data directory unless overridden via properties file.\n             *\n             * @param {string} path Relative or absolute file path. Must reside in qz data directory or a white-listed location.\n             * @param {Object} [params] Object containing file access parameters\n             *  @param {boolean} [params.sandbox=true] If relative location from root is only available to the certificate's connection, otherwise all connections\n             *  @param {boolean} [params.shared=true] If relative location from root is accessible to all users on the system, otherwise just the current user\n             *  @param {string} [params.flavor='plain'] Flavor of data format used, valid flavors are <code>[base64 | hex | plain]</code>.\n             * @returns {Promise<String|Error>} String containing the file contents\n             *\n             * @memberof qz.file\n             */\n            read: function(path, params) {\n                var param = _qz.tools.extend({ path: path }, params);\n                return _qz.websocket.dataPromise('file.read', param);\n            },\n\n            /**\n             * Writes data to the file at the given path.<br/>\n             * Due to security reasons, paths are limited to the qz data directory unless overridden via properties file.\n             *\n             * @param {string} path Relative or absolute file path. Must reside in qz data directory or a white-listed location.\n             * @param {Object} params Object containing file access parameters\n             *  @param {string} params.data File data to be written\n             *  @param {boolean} [params.sandbox=true] If relative location from root is only available to the certificate's connection, otherwise all connections\n             *  @param {boolean} [params.shared=true] If relative location from root is accessible to all users on the system, otherwise just the current user\n             *  @param {boolean} [params.append=false] Appends to the end of the file if set, otherwise overwrites existing contents\n             *  @param {string} [params.flavor='plain'] Flavor of data format used, valid flavors are <code>[base64 | file | hex | plain]</code>.\n             * @returns {Promise<null|Error>}\n             *\n             * @memberof qz.file\n             */\n            write: function(path, params) {\n                var param = _qz.tools.extend({ path: path }, params);\n                return _qz.websocket.dataPromise('file.write', param);\n            },\n\n            /**\n             * Deletes a file at given path.<br/>\n             * Due to security reasons, paths are limited to the qz data directory unless overridden via properties file.\n             *\n             * @param {string} path Relative or absolute file path. Must reside in qz data directory or a white-listed location.\n             * @param {Object} [params] Object containing file access parameters\n             *  @param {boolean} [params.sandbox=true] If relative location from root is only available to the certificate's connection, otherwise all connections\n             *  @param {boolean} [params.shared=true] If relative location from root is accessible to all users on the system, otherwise just the current user\n             * @returns {Promise<null|Error>}\n             *\n             * @memberof qz.file\n             */\n            remove: function(path, params) {\n                var param = _qz.tools.extend({ path: path }, params);\n                return _qz.websocket.dataPromise('file.remove', param);\n            },\n\n            /**\n             * Provides a continuous stream of events (and optionally data) from a local file.\n             *\n             * @param {string} path Relative or absolute directory path. Must reside in qz data directory or a white-listed location.\n             * @param {Object} [params] Object containing file access parameters\n             *  @param {boolean} [params.sandbox=true] If relative location from root is only available to the certificate's connection, otherwise all connections\n             *  @param {boolean} [params.shared=true] If relative location from root is accessible to all users on the system, otherwise just the current user\n             *  @param {Object} [params.listener] If defined, file data will be returned on events\n             *   @param {number} [params.listener.bytes=-1] Number of bytes to return or -1 for all\n             *   @param {number} [params.listener.lines=-1] Number of lines to return or -1 for all\n             *   @param {boolean} [params.listener.reverse] Controls whether data should be returned from the bottom of the file.  Default value is true for line mode and false for byte mode.\n             *   @param {string|Array<string>} [params.include] File patterns to match.  Blank values will be ignored.\n             *   @param {string|Array<string>} [params.exclude] File patterns to exclude.  Blank values will be ignored.  Takes priority over <code>params.include</code>.\n             *   @param {boolean} [params.ignoreCase=true] Whether <code>params.include</code> or <code>params.exclude</code> are case-sensitive.\n             * @returns {Promise<null|Error>}\n             * @since 2.1.0\n             *\n             * @see qz.file.setFileCallbacks\n             *\n             * @memberof qz.file\n             */\n            startListening: function(path, params) {\n                if (params && typeof params.include !== 'undefined' && !Array.isArray(params.include)) {\n                    params.include = [params.include];\n                }\n                if (params && typeof params.exclude !== 'undefined' && !Array.isArray(params.exclude)) {\n                    params.exclude = [params.exclude];\n                }\n                var param = _qz.tools.extend({ path: path }, params);\n                return _qz.websocket.dataPromise('file.startListening', param);\n            },\n\n            /**\n             * Closes listeners with the provided settings. Omitting the path parameter will result in all listeners closing.\n             *\n             * @param {string} [path] Previously opened directory path of listener to close, or omit to close all.\n             * @param {Object} [params] Object containing file access parameters\n             *  @param {boolean} [params.sandbox=true] If relative location from root is only available to the certificate's connection, otherwise all connections\n             *  @param {boolean} [params.shared=true] If relative location from root is accessible to all users on the system, otherwise just the current user\n             * @returns {Promise<null|Error>}\n             *\n             * @memberof qz.file\n             */\n            stopListening: function(path, params) {\n                var param = _qz.tools.extend({ path: path }, params);\n                return _qz.websocket.dataPromise('file.stopListening', param);\n            },\n\n            /**\n             * List of functions called for any response from a file listener.\n             *  For ERROR types event data will contain, <code>{string} message</code>.\n             *  For ACTION types event data will contain, <code>{string} file {string} eventType {string} [data]</code>.\n             *\n             * @param {Function|Array<Function>} calls Single or array of <code>Function({Object} eventData)</code> calls.\n             * @since 2.1.0\n             *\n             * @memberof qz.file\n             */\n            setFileCallbacks: function(calls) {\n                _qz.file.fileCallbacks = calls;\n            }\n        },\n\n        /**\n         * Calls related to networking information\n         * @namespace qz.networking\n         * @since 2.1.0\n         */\n        networking: {\n            /**\n             * @param {string} [hostname] Hostname to try to connect to when determining network interfaces, defaults to \"google.com\"\n             * @param {number} [port] Port to use with custom hostname, defaults to 443\n             * @returns {Promise<Object|Error>} Connected system's network information.\n             *\n             * @memberof qz.networking\n             * @since 2.1.0\n             */\n            device: function(hostname, port) {\n                // Wrap 2.0\n                if (_qz.tools.isVersion(2, 0)) {\n                    return _qz.compatible.networking(hostname, port, null, null, function(data) {\n                        return { ip: data.ipAddress, mac: data.macAddress };\n                    });\n                }\n                // Use 2.1\n                return _qz.websocket.dataPromise('networking.device', {\n                    hostname: hostname,\n                    port: port\n                });\n            },\n\n            /**\n             * Get computer hostname\n             *\n             * @param {string} [hostname] DEPRECATED Hostname to try to connect to when determining network interfaces, defaults to \"google.com\"\n             * @param {number} [port] DEPRECATED Port to use with custom hostname, defaults to 443\n             * @returns {Promise<string|Error>} Connected system's hostname.\n             *\n             * @memberof qz.networking\n             * @since 2.2.2\n             */\n            hostname: function(hostname, port) {\n                // Wrap < 2.2.2\n                if (_qz.tools.versionCompare(2, 2, 2) < 0) {\n                    return _qz.tools.promise(function(resolve, reject) {\n                        _qz.websocket.dataPromise('networking.device', { hostname: hostname, port: port }).then(function(device) {\n                            console.log(device);\n                            resolve(device.hostname);\n                        });\n                    });\n                } else {\n                    return _qz.websocket.dataPromise('networking.hostname');\n                }\n            },\n\n            /**\n             * @param {string} [hostname] Hostname to try to connect to when determining network interfaces, defaults to \"google.com\"\n             * @param {number} [port] Port to use with custom hostname, defaults to 443\n             * @returns {Promise<Array<Object>|Error>} Connected system's network information.\n             *\n             * @memberof qz.networking\n             * @since 2.1.0\n             */\n            devices: function(hostname, port) {\n                // Wrap 2.0\n                if (_qz.tools.isVersion(2, 0)) {\n                    return _qz.compatible.networking(hostname, port, null, null, function(data) {\n                        return [{ ip: data.ipAddress, mac: data.macAddress }];\n                    });\n                }\n                // Use 2.1\n                return _qz.websocket.dataPromise('networking.devices', {\n                    hostname: hostname,\n                    port: port\n                });\n            }\n        },\n\n\n        /**\n         * Calls related to signing connection requests.\n         * @namespace qz.security\n         */\n        security: {\n            /**\n             * Set promise resolver for calls to acquire the site's certificate.\n             *\n             * @param {Function|AsyncFunction|Promise<string>} promiseHandler Either a function that will be used as a promise resolver (of format <code>Function({function} resolve, {function}reject)</code>),\n             *     an async function, or a promise. Any of which should return the public certificate via their respective <code>resolve</code> call.\n             * @param {Object} [options] Configuration options for the certificate resolver\n             *  @param {boolean} [options.rejectOnFailure=[false]] Overrides default behavior to call resolve with a blank certificate on failure.\n             * @memberof qz.security\n             */\n            setCertificatePromise: function(promiseHandler, options) {\n                _qz.security.certHandler = promiseHandler;\n                _qz.security.rejectOnCertFailure = !!(options && options.rejectOnFailure);\n            },\n\n            /**\n             * Set promise factory for calls to sign API calls.\n             *\n             * @param {Function|AsyncFunction} promiseFactory Either a function that accepts a string parameter of the data to be signed\n             *     and returns a function to be used as a promise resolver (of format <code>Function({function} resolve, {function}reject)</code>),\n             *     or an async function that can take a string parameter of the data to be signed. Either of which should return the signed contents of\n             *     the passed string parameter via their respective <code>resolve</code> call.\n             *\n             * @example\n             *  qz.security.setSignaturePromise(function(dataToSign) {\n             *    return function(resolve, reject) {\n             *      $.ajax(\"/signing-url?data=\" + dataToSign).then(resolve, reject);\n             *    }\n             *  })\n             *\n             * @memberof qz.security\n             */\n            setSignaturePromise: function(promiseFactory) {\n                _qz.security.signatureFactory = promiseFactory;\n            },\n\n            /**\n             * Set which signing algorithm QZ will check signatures against.\n             *\n             * @param {string} algorithm The algorithm used in signing. Valid values: <code>[SHA1 | SHA256 | SHA512]</code>\n             * @since 2.1.0\n             *\n             * @memberof qz.security\n             */\n            setSignatureAlgorithm: function(algorithm) {\n                //warn for incompatibilities if known\n                if (!_qz.compatible.algorithm()) {\n                    return;\n                }\n\n                if ([\"SHA1\", \"SHA256\", \"SHA512\"].indexOf(algorithm.toUpperCase()) < 0) {\n                    _qz.log.error(\"Signing algorithm '\" + algorithm + \"' is not supported.\");\n                } else {\n                    _qz.security.signAlgorithm = algorithm;\n                }\n            },\n\n            /**\n             * Get the signing algorithm QZ will be checking signatures against.\n             *\n             * @returns {string} The algorithm used in signing.\n             * @since 2.1.0\n             *\n             * @memberof qz.security\n             */\n            getSignatureAlgorithm: function() {\n                return _qz.security.signAlgorithm;\n            }\n        },\n\n        /**\n         * Calls related to compatibility adjustments\n         * @namespace qz.api\n         */\n        api: {\n            /**\n             * Show or hide QZ api debugging statements in the browser console.\n             *\n             * @param {boolean} show Whether the debugging logs for QZ should be shown. Hidden by default.\n             * @returns {boolean} Value of debugging flag\n             * @memberof qz.api\n             */\n            showDebug: function(show) {\n                return (_qz.DEBUG = show);\n            },\n\n            /**\n             * Get version of connected QZ Tray application.\n             *\n             * @returns {Promise<string|Error>} Version number of QZ Tray.\n             *\n             * @memberof qz.api\n             */\n            getVersion: function() {\n                return _qz.websocket.dataPromise('getVersion');\n            },\n\n            /**\n             * Checks for the specified version of connected QZ Tray application.\n             *\n             * @param {string|number} [major] Major version to check\n             * @param {string|number} [minor] Minor version to check\n             * @param {string|number} [patch] Patch version to check\n             *\n             * @memberof qz.api\n             */\n            isVersion: _qz.tools.isVersion,\n\n            /**\n             * Checks if the connected QZ Tray application is greater than the specified version.\n             *\n             * @param {string|number} major Major version to check\n             * @param {string|number} [minor] Minor version to check\n             * @param {string|number} [patch] Patch version to check\n             * @param {string|number} [build] Build version to check\n             * @returns {boolean} True if connected version is greater than the version specified.\n             *\n             * @memberof qz.api\n             * @since 2.1.0-4\n             */\n            isVersionGreater: function(major, minor, patch, build) {\n                return _qz.tools.versionCompare(major, minor, patch, build) > 0;\n            },\n\n            /**\n             * Checks if the connected QZ Tray application is less than the specified version.\n             *\n             * @param {string|number} major Major version to check\n             * @param {string|number} [minor] Minor version to check\n             * @param {string|number} [patch] Patch version to check\n             * @param {string|number} [build] Build version to check\n             * @returns {boolean} True if connected version is less than the version specified.\n             *\n             * @memberof qz.api\n             * @since 2.1.0-4\n             */\n            isVersionLess: function(major, minor, patch, build) {\n                return _qz.tools.versionCompare(major, minor, patch, build) < 0;\n            },\n\n            /**\n             * Change the promise library used by QZ API.\n             * Should be called before any initialization to avoid possible errors.\n             *\n             * @param {Function} promiser <code>Function({function} resolver)</code> called to create new promises.\n             *\n             * @memberof qz.api\n             */\n            setPromiseType: function(promiser) {\n                _qz.tools.promise = promiser;\n            },\n\n            /**\n             * Change the SHA-256 hashing function used by QZ API.\n             * Should be called before any initialization to avoid possible errors.\n             *\n             * @param {Function} hasher <code>Function({function} message)</code> called to create hash of passed string.\n             *\n             * @memberof qz.api\n             */\n            setSha256Type: function(hasher) {\n                _qz.tools.hash = hasher;\n            },\n\n            /**\n             * Change the WebSocket handler.\n             * Should be called before any initialization to avoid possible errors.\n             *\n             * @param {Function} ws <code>Function({function} WebSocket)</code> called to override the internal WebSocket handler.\n             *\n             * @memberof qz.api\n             */\n            setWebSocketType: function(ws) {\n                _qz.tools.ws = ws;\n            }\n        },\n\n        /**\n         * Version of this JavaScript library\n         *\n         * @constant {string}\n         *\n         * @memberof qz\n         */\n        version: _qz.VERSION\n    };\n\n    return qz;\n})();\n\n\n(function() {\n    if (typeof define === 'function' && define.amd) {\n        define(qz);\n    } else if (typeof exports === 'object') {\n        module.exports = qz;\n    } else {\n        window.qz = qz;\n    }\n})();\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}}]
}